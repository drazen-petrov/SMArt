

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>SMArt.alchemy.incl &mdash; SMArt v1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> SMArt
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">SMArt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Tutorial/index.html">Tutorial</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SMArt</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../alchemy.html">SMArt.alchemy</a> &raquo;</li>
        
      <li>SMArt.alchemy.incl</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for SMArt.alchemy.incl</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">SMArt.incl</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">pd</span><span class="p">,</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">frozendict</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">do_warn</span>
<span class="kn">from</span> <span class="nn">SMArt.graph</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="c1"># bond breaking / making (if True, max dist for bond breaking needed)</span>
<span class="c1"># breaking other bonded interactions (angles, dihedrals, impropers (needed if bond breaks = True)</span>
    <span class="c1"># interesting for matching dihedrals in gromacs with different multiplicity or rings with one bond (2 atoms) partial solutions (see below)</span>
<span class="c1"># ring solutions - all or nothing; all or one atom; all or one bond (two atoms); partial (needs bond breaking)</span>
<span class="c1"># exclusions / pairs</span>

<span class="kn">from</span> <span class="nn">SMArt.md.incl</span> <span class="kn">import</span> <span class="n">Dummy</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">class Dummy:</span>
<span class="sd">    m = None</span>
<span class="sd">    p_ch = None</span>
<span class="sd">    a_type = None</span>
<span class="sd">    coord = np.array([np.nan] * 3)</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Branch"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch">[docs]</a><span class="k">class</span> <span class="nc">Branch</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">neigh_count</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roots</span> <span class="o">=</span> <span class="n">roots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="n">parents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neigh_count</span> <span class="o">=</span> <span class="n">neigh_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nv</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Nv&#39;</span><span class="p">,</span> <span class="n">neigh_count</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="c1"># V_in_branch could be tuple, or frozendict with levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;V_in_branch&#39;</span><span class="p">,</span> <span class="p">())</span>

<div class="viewcode-block" id="Branch.combine_neigh_count"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.combine_neigh_count">[docs]</a>    <span class="k">def</span> <span class="nf">combine_neigh_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_branch</span><span class="p">,</span> <span class="n">flag_other_neigh_count</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">flag_other_neigh_count</span><span class="p">:</span>
            <span class="n">other_neigh_count</span> <span class="o">=</span> <span class="n">other_branch</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_neigh_count</span> <span class="o">=</span> <span class="n">other_branch</span><span class="o">.</span><span class="n">neigh_count</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_neigh_count</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n1</span> <span class="o">&gt;</span> <span class="n">n2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other_neigh_count</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n1</span> <span class="o">-</span> <span class="n">n2</span><span class="p">))])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n2</span> <span class="o">-</span> <span class="n">n1</span><span class="p">)),</span> <span class="n">other_neigh_count</span><span class="p">])</span></div>

<div class="viewcode-block" id="Branch.sum_neigh_count"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.sum_neigh_count">[docs]</a>    <span class="k">def</span> <span class="nf">sum_neigh_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_branch</span><span class="p">,</span> <span class="n">flag_other_neigh_count</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count</span><span class="p">(</span><span class="n">other_branch</span><span class="p">,</span> <span class="n">flag_other_neigh_count</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Branch.calculate_pair_estimate"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.calculate_pair_estimate">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_pair_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_branch</span><span class="p">):</span>
        <span class="n">stacked_neigh_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count</span><span class="p">(</span><span class="n">other_branch</span><span class="p">)</span>
        <span class="n">max_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_stacked_neigh_count_pair_estimate</span><span class="p">(</span><span class="n">stacked_neigh_count</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nv</span><span class="p">,</span> <span class="n">other_branch</span><span class="o">.</span><span class="n">Nv</span><span class="p">),</span> <span class="n">max_match</span><span class="p">)</span></div>

<div class="viewcode-block" id="Branch.calculate_branch_pair_estimate"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.calculate_branch_pair_estimate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_branch_pair_estimate</span><span class="p">(</span><span class="n">branches</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">calculate_pair_estimate</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Branch.calculate_neigh_count_pair_estimate"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.calculate_neigh_count_pair_estimate">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">calculate_neigh_count_pair_estimate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">neigh_count_pair</span><span class="p">):</span>
        <span class="n">stacked_neigh_count</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">combine_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">calculate_stacked_neigh_count_pair_estimate</span><span class="p">(</span><span class="n">stacked_neigh_count</span><span class="p">)</span></div>

<div class="viewcode-block" id="Branch.calculate_stacked_neigh_count_pair_estimate"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.calculate_stacked_neigh_count_pair_estimate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_stacked_neigh_count_pair_estimate</span><span class="p">(</span><span class="n">stacked_neigh_count</span><span class="p">):</span>
        <span class="n">max_match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">stacked_neigh_count</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">max_match</span></div>

<div class="viewcode-block" id="Branch.combine_neigh_count_list"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.combine_neigh_count_list">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combine_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">neigh_count_list</span><span class="p">:</span>
            <span class="n">len_lists</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ncl</span><span class="p">)</span> <span class="k">for</span> <span class="n">ncl</span> <span class="ow">in</span> <span class="n">neigh_count_list</span><span class="p">]</span>
            <span class="n">N_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">len_lists</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ncl</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N_max</span> <span class="o">-</span> <span class="n">len_lists</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ncl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span></div>

<div class="viewcode-block" id="Branch.sum_neigh_count_list"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.sum_neigh_count_list">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">neigh_count_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Branch</span><span class="o">.</span><span class="n">combine_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span></div>

<div class="viewcode-block" id="Branch.sum_neigh_count_list_branches"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.sum_neigh_count_list_branches">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sum_neigh_count_list_branches</span><span class="p">(</span><span class="n">branches</span><span class="p">):</span>
        <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
            <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">sum_neigh_count</span><span class="p">(</span><span class="n">temp_neigh_count</span><span class="p">,</span> <span class="n">flag_other_neigh_count</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp_neigh_count</span></div>

<div class="viewcode-block" id="Branch.combine_mutually_exclusive_neigh_count_list"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.combine_mutually_exclusive_neigh_count_list">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combine_mutually_exclusive_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates combined neigh_count from a list of neigh_count, such that it takes max at each position</span>
<span class="sd">        :param neigh_count_list:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">temp_combined_neigh_count_list</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">combine_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp_combined_neigh_count_list</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Branch.combine_mutually_exclusive_neigh_count_list_with_max_Nv"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.Branch.combine_mutually_exclusive_neigh_count_list_with_max_Nv">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combine_mutually_exclusive_neigh_count_list_with_max_Nv</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates combined neigh_count from a list of neigh_count, such that it takes max at each position</span>
<span class="sd">        returns also the max Nv from the neigh count lists</span>
<span class="sd">        :param neigh_count_list:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">temp_combined_neigh_count_list</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">combine_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp_combined_neigh_count_list</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">temp_combined_neigh_count_list</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span></div></div>

<div class="viewcode-block" id="TopGraphProperties"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties">[docs]</a><span class="k">class</span> <span class="nc">TopGraphProperties</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    graph properties: rings, different branches, dummy-match estimates etc...</span>

<span class="sd">    attributes within g:</span>
<span class="sd">        rings, rings_map</span>
<span class="sd">        within each ring:</span>
<span class="sd">            breaks, breaks_map, break_parents, independent_parts, independent_parts_map, independent_parts_graph</span>

<span class="sd">    attributes within the instance:</span>
<span class="sd">        g, available_Vs, non_available_Vs</span>
<span class="sd">        first_non_ring_neighbours</span>
<span class="sd">        branches, ring_branches - true branches</span>
<span class="sd">        combined_FromRing_branches - for each ring / atom in r, a combined branch to all parents that are not in r</span>
<span class="sd">        each of ring_branches</span>
<span class="sd">            combined_linear_branch - max of neighbouring combined_FromRing_branches within the r</span>
<span class="sd">            fake_branches - it&#39;s a full branch having a single parent within the r</span>
<span class="sd">        break_branches - for each ring</span>
<span class="sd">        combined_FromRing_branches - branch that is a combination off branches going out of the r</span>
<span class="sd">        combined_branches, linear_combined_branches - for each atom, combination of all available branches</span>
<span class="sd">                if v in ring, linear_combined_branches is a bit different as it only takes first neighbours within r</span>
<span class="sd">        dummy_estimates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">in_solution_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">in_solution_dummy_match_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">remove_V_in_branch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        graph properties: rings, different branches, dummy-match estimates etc...</span>
<span class="sd">        :param g:</span>
<span class="sd">        :param available_Vs:</span>
<span class="sd">        :param non_available_Vs:</span>
<span class="sd">        :param in_solution:</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            non__av_insol_Vs</span>
<span class="sd">            flag_get_ind_ring_parts - if False, no ind_ring_parts (in case partial ring match not allowed)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;non__av_insol_Vs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">available_Vs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_dummy_match_Vs</span>\
                <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;non__av_insol_Vs&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">available_Vs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_dummy_match_Vs</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_g_non__available__insol_Vs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">available_Vs</span><span class="p">,</span> <span class="n">non_available_Vs</span><span class="p">,</span> <span class="n">in_solution_Vs</span><span class="p">,</span> <span class="n">in_solution_dummy_match_Vs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_solution_Vs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_dummy_match_Vs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__get_rings</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># gets the rings and rings_map (independent of available_Vs)</span>
        <span class="c1">#self.__get_independent_ring_parts(flag_get_ind_ring_branches = False)</span>
        <span class="k">if</span> <span class="s1">&#39;ring_independent_parts_availability_map&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ring_independent_parts_availability_map</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ring_independent_parts_availability_map&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_independent_ring_parts_availability_map</span><span class="p">()</span>
        <span class="k">if</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># this is a generalized way</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_branches</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_combined_neigh_count_Nv</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_dummy_match_estimates</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_dummy_match_estimates_in_solution</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span><span class="c1">##################################################### fix</span>
            <span class="c1"># this should be if we include all vertices as available</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_initial_branches</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_independent_ring_parts</span><span class="p">(</span><span class="n">branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">,</span> <span class="n">ring_branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">,</span>
                                              <span class="n">combined_FromRing_branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__initial_combined_neigh_count</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_initial_dummy_match_estimate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">remove_V_in_branch</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_V_in_branch</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_g_non__available__insol_Vs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">in_solution_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">in_solution_dummy_match_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">available_Vs</span><span class="p">:</span>
            <span class="n">available_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">available_Vs</span><span class="p">)</span>
            <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span> <span class="o">-</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">available_Vs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">non_available_Vs</span><span class="p">:</span>
            <span class="n">available_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span> <span class="o">-</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">non_available_Vs</span><span class="p">)</span>
            <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">non_available_Vs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">available_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span>
            <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">in_solution_Vs</span><span class="p">:</span>
            <span class="n">in_solution_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">in_solution_Vs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_solution_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">in_solution_dummy_match_Vs</span><span class="p">:</span>
            <span class="n">in_solution_dummy_match_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">in_solution_dummy_match_Vs</span><span class="p">)</span>
            <span class="n">in_solution_Vs</span>  <span class="o">=</span> <span class="n">in_solution_Vs</span> <span class="o">|</span> <span class="n">in_solution_dummy_match_Vs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_solution_dummy_match_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">in_solution_Vs</span><span class="p">:</span>
            <span class="n">available_Vs</span> <span class="o">=</span> <span class="n">available_Vs</span> <span class="o">-</span> <span class="n">in_solution_Vs</span>
            <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="n">non_available_Vs</span> <span class="o">|</span> <span class="n">in_solution_Vs</span>
        <span class="k">return</span> <span class="n">available_Vs</span><span class="p">,</span> <span class="n">non_available_Vs</span><span class="p">,</span> <span class="n">in_solution_Vs</span><span class="p">,</span> <span class="n">in_solution_dummy_match_Vs</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_g_check_branch</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag_use_V_in_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">flag_use_V_in_branch</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">:</span>
                <span class="n">do_warn</span><span class="p">(</span><span class="s2">&quot;can&#39;t check branch without V_in_branch&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">roots</span><span class="p">)</span>
        <span class="n">temp_neigh_count</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_neigh_count_from_generator</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">,</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">temp_neigh_count</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">Nv</span>

<div class="viewcode-block" id="TopGraphProperties.check_branches"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.check_branches">[docs]</a>    <span class="k">def</span> <span class="nf">check_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">:</span>
            <span class="n">flag_use_V_in_branch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flag_use_V_in_branch</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_branch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag_use_V_in_branch</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_branch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag_use_V_in_branch</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">fake_b</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">fake_branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_branch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">fake_b</span><span class="p">,</span> <span class="n">flag_use_V_in_branch</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_branch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag_use_V_in_branch</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">break_branches</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ring_ind_part_branches</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">break_branches</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ring_ind_part_branches</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_g_check_branch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag_use_V_in_branch</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_g_get_rings</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">flag_get_ind_ring_parts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rerun_get_rings</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;rings_map&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;rings&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">rerun_get_rings</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">rings</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">find_rings_graph</span><span class="p">(</span><span class="n">flag_root_at</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">g</span><span class="o">.</span><span class="n">rings_map</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">r_graph</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">rings</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r_graph</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_graph</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_g_get_independent_ring_parts</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">flag_get_ind_ring_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flag_get_ind_ring_parts</span><span class="o">=</span><span class="n">flag_get_ind_ring_parts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_rings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag_get_ind_ring_parts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rerun_get_rings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g_get_rings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">flag_get_ind_ring_parts</span><span class="o">=</span><span class="n">flag_get_ind_ring_parts</span><span class="p">,</span> <span class="n">rerun_get_rings</span><span class="o">=</span><span class="n">rerun_get_rings</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_g_get_independent_ring_parts</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">flag_get_ind_ring_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ring_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">combined_FromRing_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">flag_get_ind_ring_parts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">break_branches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">rings</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">breaks</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">r</span><span class="o">.</span><span class="n">break_parents</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">flag_get_ind_ring_parts</span><span class="p">:</span> <span class="c1"># all is one independent part if partial match is not allowed...</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">breaks</span><span class="p">:</span>
                                <span class="n">temp_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
                                <span class="n">r</span><span class="o">.</span><span class="n">breaks</span><span class="p">[</span><span class="n">temp_pair</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="n">r</span><span class="o">.</span><span class="n">break_parents</span><span class="p">[</span><span class="n">temp_pair</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="n">first_neigh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">BFS_l</span><span class="p">(</span><span class="n">temp_pair</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flag_v_list</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                                <span class="n">ind_ring_part_i2del</span><span class="p">,</span> <span class="n">flag_already_searched_ind_ring_parts</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                                <span class="k">while</span> <span class="n">first_neigh</span><span class="p">:</span>
                                    <span class="n">temp_first_neigh</span> <span class="o">=</span> <span class="n">first_neigh</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                                    <span class="n">new_ind_ring_part</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">temp_pair</span><span class="p">)</span>
                                    <span class="n">temp_branch</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">_BFS</span><span class="p">(</span><span class="n">temp_first_neigh</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">new_ind_ring_part</span><span class="p">))</span>
                                    <span class="n">ind_ring_part_parents</span> <span class="o">=</span> <span class="n">first_neigh</span> <span class="o">&amp;</span> <span class="n">temp_branch</span>
                                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_branch</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                                        <span class="n">new_ind_ring_part</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">new_ind_ring_part</span><span class="p">)</span>
                                        <span class="n">ind_ring_part_parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">temp_first_neigh</span><span class="p">)</span>
                                        <span class="n">r</span><span class="o">.</span><span class="n">break_parents</span><span class="p">[</span><span class="n">temp_pair</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind_ring_part_parents</span><span class="p">)</span>
                                        <span class="n">r</span><span class="o">.</span><span class="n">breaks</span><span class="p">[</span><span class="n">temp_pair</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">temp_branch</span><span class="p">))</span>
                                        <span class="k">if</span> <span class="n">ind_ring_part_i2del</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flag_already_searched_ind_ring_parts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                            <span class="n">flag_already_searched_ind_ring_parts</span> <span class="o">=</span> <span class="kc">True</span>
                                            <span class="k">for</span> <span class="n">temp_ind_ring_part_i</span><span class="p">,</span> <span class="n">temp_ind_ring_part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="p">):</span>
                                                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp_ind_ring_part</span> <span class="ow">and</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">temp_ind_ring_part</span><span class="p">:</span>
                                                    <span class="n">ind_ring_part_i2del</span> <span class="o">=</span> <span class="n">temp_ind_ring_part_i</span>
                                                    <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind_ring_part_i2del</span><span class="p">)</span>
                                                    <span class="k">break</span>
                                        <span class="k">if</span> <span class="n">ind_ring_part_i2del</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                            <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ind_ring_part</span><span class="p">)</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_ind_ring_part</span> <span class="o">&amp;</span> <span class="n">new_ind_ring_part</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">r</span><span class="o">.</span><span class="n">breaks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">temp_pair</span><span class="p">)</span>
                                        <span class="n">r</span><span class="o">.</span><span class="n">break_parents</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">temp_pair</span><span class="p">)</span>
                                    <span class="n">first_neigh</span> <span class="o">=</span> <span class="n">first_neigh</span> <span class="o">-</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">ind_ring_part_parents</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">)]</span>
            <span class="n">r</span><span class="o">.</span><span class="n">breaks_map</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">temp_break</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">breaks</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp_break</span><span class="p">:</span>
                    <span class="n">r</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_break</span>
            <span class="n">r</span><span class="o">.</span><span class="n">independent_parts_map</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">independent_parts_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">independent_parts_adj</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">ind_ring_part</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="p">:</span>
                <span class="n">independent_parts_adj</span><span class="p">[</span><span class="n">ind_ring_part</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ind_ring_part</span><span class="p">:</span>
                    <span class="n">r</span><span class="o">.</span><span class="n">independent_parts_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind_ring_part</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ind_ring_part_pair</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ind_ring_part_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ind_ring_part_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                        <span class="n">independent_parts_adj</span><span class="p">[</span><span class="n">ind_ring_part_pair</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind_ring_part_pair</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">r</span><span class="o">.</span><span class="n">independent_parts_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">independent_parts_adj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flag_get_ind_ring_branches</span><span class="p">:</span> <span class="c1"># this part depends on available_Vs!!!!!!!!!!!!</span>
                <span class="n">break_branches</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">temp_pair</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">break_parents</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ind_ring_part_parents</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">break_parents</span><span class="p">[</span><span class="n">temp_pair</span><span class="p">]:</span>
                        <span class="n">temp_ind_ring_part_branch</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__initial_r_get_ind_ring_branch_fromRB</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">temp_pair</span><span class="p">,</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_ring_part_parents</span><span class="p">),</span> <span class="n">branches</span><span class="p">,</span> <span class="n">ring_branches</span><span class="p">,</span> <span class="n">combined_FromRing_branches</span><span class="p">)</span>
                        <span class="n">break_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">temp_pair</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_ind_ring_part_branch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">break_branches</span> <span class="c1"># not needed in principle</span>

    <span class="k">def</span> <span class="nf">__get_independent_ring_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">break_branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_get_independent_ring_parts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_g_get_independent_ring_parts_availability_map</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">non_available_Vs</span><span class="p">,</span> <span class="n">in_solution_Vs</span><span class="p">):</span>
        <span class="n">ring_ind_part_non_available_Vs</span> <span class="o">=</span> <span class="n">non_available_Vs</span> <span class="o">-</span> <span class="n">in_solution_Vs</span>
        <span class="n">ring_independent_parts_availability_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">rings</span><span class="p">:</span>
            <span class="n">flag_all_non_available</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">roots_ind_part</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">visited_ind_part</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">ring_independent_parts_availability_map</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">ind_part</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ind_part</span> <span class="o">&amp;</span> <span class="n">ring_ind_part_non_available_Vs</span><span class="p">:</span>
                    <span class="n">ring_independent_parts_availability_map</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">ind_part</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">ind_part_in_solution_Vs</span> <span class="o">=</span> <span class="n">ind_part</span> <span class="o">&amp;</span> <span class="n">in_solution_Vs</span>
                    <span class="k">if</span> <span class="n">ind_part_in_solution_Vs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ind_part_in_solution_Vs</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">):</span>
                            <span class="n">flag_all_non_available</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                        <span class="n">roots_ind_part</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind_part</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ring_independent_parts_availability_map</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">ind_part</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">ind_part</span> <span class="o">&amp;</span> <span class="n">in_solution_Vs</span><span class="p">:</span>
                        <span class="n">visited_ind_part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ind_part</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flag_all_non_available</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ind_part</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="p">:</span>
                    <span class="n">ring_independent_parts_availability_map</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">ind_part</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ind_part</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts_graph</span><span class="o">.</span><span class="n">_BFS</span><span class="p">(</span><span class="n">roots_ind_part</span><span class="p">,</span> <span class="n">flag_v_list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited_ind_part</span><span class="p">):</span>
                    <span class="n">ring_independent_parts_availability_map</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">ind_part</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">ring_independent_parts_availability_map</span>


    <span class="k">def</span> <span class="nf">__get_independent_ring_parts_availability_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ring_independent_parts_availability_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g_get_independent_ring_parts_availability_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span>
                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_solution_Vs</span><span class="p">)</span>

    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions # helper functions #</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions # helper functions #</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions # helper functions #</span>

<div class="viewcode-block" id="TopGraphProperties.update_neigh_count_VinB"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.update_neigh_count_VinB">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">update_neigh_count_VinB</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">collect_res</span><span class="p">,</span> <span class="n">V_in_branch</span><span class="p">):</span>
        <span class="n">V_in_branch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">update_neigh_count</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">collect_res</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopGraphProperties.update_neigh_count"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.update_neigh_count">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">update_neigh_count</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">collect_res</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">collect_res</span><span class="p">):</span>
            <span class="n">collect_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collect_res</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_neigh_count_from_generator"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_neigh_count_from_generator">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_neigh_count_from_generator</span><span class="p">(</span><span class="n">BFS_generator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">collect_res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">BFS_generator</span><span class="p">:</span>
            <span class="n">V_in_branch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">collect_res</span><span class="p">):</span>
                <span class="n">collect_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collect_res</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">collect_res</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">V_in_branch</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_neigh_count_from_generator_VinB_list</span><span class="p">(</span><span class="n">BFS_generator</span><span class="p">):</span>
        <span class="n">collect_res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">BFS_generator</span><span class="p">:</span>
            <span class="n">V_in_branch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">collect_res</span><span class="p">):</span>
                <span class="n">collect_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collect_res</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">collect_res</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">V_in_branch</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_neigh_count_from_generator_VinB_frozendict</span><span class="p">(</span><span class="n">BFS_generator</span><span class="p">):</span>
        <span class="n">collect_res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">BFS_generator</span><span class="p">:</span>
            <span class="n">V_in_branch</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span><span class="n">l</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">collect_res</span><span class="p">):</span>
                <span class="n">collect_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collect_res</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">collect_res</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">frozendict</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_g_get_neigh_count_Vpair</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">v0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_neigh_count_from_generator</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">))</span>

<div class="viewcode-block" id="TopGraphProperties.get_neigh_count_Vpair"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_neigh_count_Vpair">[docs]</a>    <span class="k">def</span> <span class="nf">get_neigh_count_Vpair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">v0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neigh_count_from_generator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">))</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_g_get_neigh_count_roots_parents</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">):</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="n">temp_generator</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">,</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_neigh_count_from_generator</span><span class="p">(</span><span class="n">temp_generator</span><span class="p">)</span>

<div class="viewcode-block" id="TopGraphProperties.get_neigh_count_roots_parents"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_neigh_count_roots_parents">[docs]</a>    <span class="k">def</span> <span class="nf">get_neigh_count_roots_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">):</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="n">temp_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">,</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neigh_count_from_generator</span><span class="p">(</span><span class="n">temp_generator</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__g_non__available_to_visited_v0</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__g_non__available_to_visited_roots</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="n">v0</span><span class="p">],</span> <span class="n">available_Vs</span><span class="p">,</span> <span class="n">non_available_Vs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__g_non__available_to_visited_roots</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__g_non__available_Vs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">available_Vs</span><span class="p">,</span> <span class="n">non_available_Vs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__roots2visited</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">non_available_Vs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__g_non__available_Vs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">non_available_Vs</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">non_available_Vs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">available_Vs</span><span class="p">:</span>
            <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span> <span class="o">-</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">available_Vs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">non_available_Vs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__roots2visited</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">non_available_Vs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">non_available_Vs</span><span class="p">:</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">|</span> <span class="n">non_available_Vs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">visited</span>

    <span class="k">def</span> <span class="nf">__available_to_visited_v0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__roots2visited</span><span class="p">([</span><span class="n">v0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__available_to_visited_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">available_Vs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__roots2visited</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_g_get_branch_roots_parents</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">non_available_Vs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__g_non__available_to_visited_roots</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">available_Vs</span><span class="p">,</span> <span class="n">non_available_Vs</span><span class="p">)</span>
        <span class="n">temp_generator</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">,</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_neigh_count_from_generator</span><span class="p">(</span><span class="n">temp_generator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_r_get_branch_roots_parents_fromBR</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">branches</span><span class="p">,</span> <span class="n">ring_branches</span><span class="p">,</span> <span class="n">combined_FromRing_branches</span><span class="p">):</span>
        <span class="n">BFS_generator</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">),</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">BFS_generator</span><span class="p">:</span>
            <span class="n">temp_combined_FromRing_b</span> <span class="o">=</span> <span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
            <span class="n">V_in_branch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_combined_FromRing_b</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
            <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">temp_combined_FromRing_b</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
            <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_neigh_count</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">b_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__initial_r_get_sorted_ring_linear_combined_branches</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">ring_branches</span><span class="p">):</span>
        <span class="n">temp_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">combined_linear_branch</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">]</span>
        <span class="n">temp_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">tot_Nv</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp_list</span>

<span class="c1"># most general cases - not using already known branches</span>
    <span class="k">def</span> <span class="nf">__get_branch_Vpair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span> <span class="c1"># does not allow for available_Vs argument - all Vs available</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">(</span><span class="n">v0</span><span class="p">,)</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">,)</span>
        <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neigh_count_Vpair</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">)</span>

<div class="viewcode-block" id="TopGraphProperties.get_branch_Vpair"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_branch_Vpair">[docs]</a>    <span class="k">def</span> <span class="nf">get_branch_Vpair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">(</span><span class="n">v0</span><span class="p">,)</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">,)</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__roots2visited</span><span class="p">([</span><span class="n">v0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">)</span>
        <span class="n">temp_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">)</span>
        <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neigh_count_from_generator</span><span class="p">(</span><span class="n">temp_generator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__get_branch_roots_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">):</span> <span class="c1"># does not allow for available_Vs argument - all Vs available</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="n">temp_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">,</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neigh_count_from_generator</span><span class="p">(</span><span class="n">temp_generator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">)</span>

<div class="viewcode-block" id="TopGraphProperties.get_branch_roots_parents"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_branch_roots_parents">[docs]</a>    <span class="k">def</span> <span class="nf">get_branch_roots_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">):</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__roots2visited</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">)</span>
        <span class="n">temp_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">,</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neigh_count_from_generator</span><span class="p">(</span><span class="n">temp_generator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">)</span></div>

    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions # helper functions #</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions # helper functions #</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions # helper functions #</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># __initaial all available atoms # __initaial all available atoms # __initaial all available atoms #################</span>
    <span class="c1"># __initaial all available atoms # __initaial all available atoms # __initaial all available atoms #################</span>
    <span class="c1">####################################################################################################################</span>

    <span class="c1"># getting branches - assuming only bonded pairs and non-fake branches</span>
    <span class="c1"># get branch recursively using known branches</span>
    <span class="k">def</span> <span class="nf">__get_initial_first_non_ring_neighbour</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
            <span class="n">first_neighbours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
                <span class="n">first_neighbours</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
                    <span class="n">first_neighbours</span> <span class="o">=</span> <span class="n">first_neighbours</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">first_neighbours</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_initial_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># does not allow for available_Vs argument - all Vs available</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__get_initial_first_non_ring_neighbour</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__get_ring_branches_recursive</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_true_branch_Vpair_recursive</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initial_get_ring_combined_linear_branches_fromBR</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__get_true_branch_Vpair_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="n">v0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span>
                <span class="n">temp_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_ring_branches_recursive</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">V_in_branch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
                <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
                <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_neigh_count</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v_next</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v_next</span><span class="o">!=</span><span class="n">v0</span><span class="p">:</span>
                <span class="n">temp_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_true_branch_Vpair_recursive</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v_next</span><span class="p">)</span>
                <span class="n">V_in_branch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
                <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
                <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_neigh_count</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="n">linear_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v0</span><span class="p">,),</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="p">),</span> <span class="n">b_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="n">linear_branch</span>
        <span class="k">return</span> <span class="n">linear_branch</span>

    <span class="k">def</span> <span class="nf">__get_ring_branches_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">r</span><span class="p">]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">],</span> <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">v0</span><span class="p">]),</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">temp_comb_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initial_get_ring_combined_FromRing_branch_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">V_in_branch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_comb_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
            <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">temp_comb_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
            <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_neigh_count</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="n">ring_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v0</span><span class="p">,),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">]),</span> <span class="n">b_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring_branch</span>
        <span class="c1"># do fake linear branches from each first neighbour within the ring</span>
        <span class="n">ring_branch</span><span class="o">.</span><span class="n">fake_branches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
            <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span>  <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">v0</span><span class="p">])):</span>
                <span class="n">temp_comb_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initial_get_ring_combined_FromRing_branch_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">temp_comb_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
                <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_neigh_count</span><span class="p">)</span>
            <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
            <span class="n">within_ring_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v0</span><span class="p">,),</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="p">),</span> <span class="n">b_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">)</span>
            <span class="n">ring_branch</span><span class="o">.</span><span class="n">fake_branches</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="n">within_ring_branch</span>
        <span class="k">return</span> <span class="n">ring_branch</span>

    <span class="k">def</span> <span class="nf">__initial_get_FromRing_branches_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ring_outside_r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">ring_outside_r</span> <span class="o">!=</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_ring_branches_recursive</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ring_outside_r</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v_outside_r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_true_branch_Vpair_recursive</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v_outside_r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__initial_get_ring_combined_FromRing_branch_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">temp_branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initial_get_FromRing_branches_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
            <span class="n">V_in_branch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">b_neigh_count</span><span class="p">)</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]),</span> <span class="p">(</span><span class="n">v</span><span class="p">,),</span> <span class="n">b_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__initial_r_get_ind_ring_branch_fromRB</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">temp_pair</span><span class="p">,</span> <span class="n">ind_ring_part_parents</span><span class="p">,</span> <span class="n">branches</span><span class="p">,</span> <span class="n">ring_branches</span><span class="p">,</span>
                                      <span class="n">combined_FromRing_branches</span><span class="p">):</span>
        <span class="n">temp_b</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_r_get_branch_roots_parents_fromBR</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">temp_pair</span><span class="p">,</span> <span class="n">ind_ring_part_parents</span><span class="p">,</span> <span class="n">branches</span><span class="p">,</span> <span class="n">ring_branches</span><span class="p">,</span> <span class="n">combined_FromRing_branches</span><span class="p">)</span>
        <span class="n">temp_b</span><span class="o">.</span><span class="n">tot_Nv</span> <span class="o">=</span> <span class="n">temp_b</span><span class="o">.</span><span class="n">Nv</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp_pair</span><span class="p">:</span>
            <span class="n">FromRing_b</span> <span class="o">=</span> <span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
            <span class="n">temp_b</span><span class="o">.</span><span class="n">tot_Nv</span> <span class="o">+=</span> <span class="n">FromRing_b</span><span class="o">.</span><span class="n">Nv</span>
        <span class="k">return</span> <span class="n">temp_b</span>

    <span class="k">def</span> <span class="nf">__initial_get_ring_combined_linear_branches_fromBR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initial_g_get_ring_combined_linear_branches_fromBR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__initial_g_get_ring_combined_linear_branches_fromBR</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">ring_branches</span><span class="p">,</span> <span class="n">combined_FromRing_branches</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">rings</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
                <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span><span class="o">.</span><span class="n">neigh_count</span> <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span>
                <span class="n">Nv_max</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">Nv_max</span> <span class="o">&lt;</span> <span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span><span class="p">:</span>
                        <span class="n">Nv_max</span> <span class="o">=</span> <span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span>
                <span class="n">combined_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">combine_mutually_exclusive_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
                <span class="n">combined_linear_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v</span><span class="p">,),</span> <span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="n">combined_neigh_count</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_max</span><span class="p">)</span>
                <span class="n">combined_linear_branch</span><span class="o">.</span><span class="n">tot_Nv</span> <span class="o">=</span> <span class="n">combined_linear_branch</span><span class="o">.</span><span class="n">Nv</span> <span class="o">+</span> <span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span><span class="c1"># - 1 (this minus one is actually not wrong, but we use this to get to the total number of atoms, including the roots...)</span>
                <span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">combined_linear_branch</span> <span class="o">=</span> <span class="n">combined_linear_branch</span>

    <span class="k">def</span> <span class="nf">__initial_combined_neigh_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#self.ring_combined_branches, self.linear_combined_branches =</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initial_g_get_combined_neigh_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__initial_g_get_combined_neigh_count</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">branches</span><span class="p">,</span> <span class="n">ring_branches</span><span class="p">):</span>
        <span class="n">combined_branches</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1">#        ring_combined_branches = {}</span>
<span class="c1">#        linear_combined_branches = {}</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
            <span class="n">Nv_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
                <span class="n">Nv_sum</span><span class="o">+=</span><span class="n">b</span><span class="o">.</span><span class="n">Nv</span>
            <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp_neigh_count</span><span class="p">]</span>
                <span class="n">Nv_sum_normal</span> <span class="o">=</span> <span class="n">Nv_sum</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
                    <span class="n">Nv_sum_normal</span><span class="o">+=</span><span class="n">b</span><span class="o">.</span><span class="n">Nv</span>
                <span class="n">comb_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
                <span class="n">ring_combined_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v</span><span class="p">,),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]),</span> <span class="n">comb_neigh_count</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum_normal</span><span class="p">)</span>
                <span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring_combined_branch</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                ring_combined_branches[v] = ring_combined_branch</span>
<span class="sd">                neigh_count_list = [temp_neigh_count]</span>
<span class="sd">                Nv_sum_linear = Nv_sum</span>
<span class="sd">                for b in ring_branches[v].values():</span>
<span class="sd">                    neigh_count_list.append(b.combined_linear_branch.neigh_count)</span>
<span class="sd">                    Nv_sum_linear+=b.combined_linear_branch.Nv</span>
<span class="sd">                comb_neigh_count = Branch.sum_neigh_count_list(neigh_count_list)</span>
<span class="sd">                linear_combined_branch = Branch((v,), tuple(g.adj[v]), comb_neigh_count, Nv = Nv_sum_linear)</span>
<span class="sd">                linear_combined_branches[v] = linear_combined_branch</span>
<span class="sd">                &quot;&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linear_combined_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v</span><span class="p">,),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]),</span> <span class="n">temp_neigh_count</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum</span><span class="p">)</span>
                <span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">linear_combined_branch</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                linear_combined_branches[v] = linear_combined_branch</span>
<span class="sd">                ring_combined_branches[v] = None</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combined_branches</span>
<span class="c1">#        return ring_combined_branches, linear_combined_branches</span>

    <span class="k">def</span> <span class="nf">__get_initial_dummy_match_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dummy_estimates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sorted_RLCBs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings</span><span class="p">:</span>
            <span class="n">sorted_RLCBs</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initial_r_get_sorted_ring_linear_combined_branches</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
            <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">Vs_independent</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">temp_ind_ring_part</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp_ind_ring_part</span><span class="p">:</span> <span class="c1"># finding independent ring parts with this atom</span>
                        <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">temp_ind_ring_part</span><span class="p">:</span> <span class="c1"># looping over each atom of the independent part</span>
                            <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
                                    <span class="k">for</span> <span class="n">break_branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">break_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">r</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">[</span><span class="n">v1</span><span class="p">]]:</span>
                                        <span class="k">if</span> <span class="n">break_branch</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">temp_ind_ring_part</span><span class="p">:</span>
                                            <span class="k">if</span> <span class="n">max_Nv_neigh_branches</span> <span class="o">&lt;</span> <span class="n">break_branch</span><span class="o">.</span><span class="n">tot_Nv</span><span class="p">:</span>
                                                <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="n">break_branch</span><span class="o">.</span><span class="n">tot_Nv</span>
                            <span class="c1">#else:Vs_independent.append(v1)</span>
                            <span class="k">if</span> <span class="n">v1</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                                <span class="n">Vs_independent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
                <span class="n">temp_max_Nv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_get_max_Nv_ring_linear_combined_branch</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">Vs_independent</span><span class="p">,</span> <span class="n">sorted_RLCBs</span><span class="p">[</span><span class="n">r</span><span class="p">],</span>
                                                                             <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">max_Nv_neigh_branches</span> <span class="o">&lt;</span> <span class="n">temp_max_Nv</span><span class="p">:</span>
                    <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="n">temp_max_Nv</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">Nv</span> <span class="o">&gt;</span> <span class="n">max_Nv_neigh_branches</span><span class="p">:</span>
                    <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">Nv</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dummy_estimates</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_Nv_neigh_branches</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1">#                                                   END                                                            #</span>
    <span class="c1"># __initaial all available atoms # __initaial all available atoms # __initaial all available atoms #################</span>
    <span class="c1">####################################################################################################################</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># allowing for non__available_Vs # allowing for non__available_Vs # allowing for non__available_Vs #################</span>
    <span class="c1"># allowing for non__available_Vs # allowing for non__available_Vs # allowing for non__available_Vs #################</span>
    <span class="c1"># allowing for non__available_Vs # allowing for non__available_Vs # allowing for non__available_Vs #################</span>
    <span class="c1">####################################################################################################################</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions ##</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions ##</span>
    <span class="c1">####################################################################################################################</span>

<div class="viewcode-block" id="TopGraphProperties.get_first_non_ring_neighbour"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_first_non_ring_neighbour">[docs]</a>    <span class="k">def</span> <span class="nf">get_first_non_ring_neighbour</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">:</span>
            <span class="n">first_neighbours</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span>
            <span class="k">if</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
                    <span class="n">first_neighbours</span> <span class="o">=</span> <span class="n">first_neighbours</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">first_neighbours</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopGraphProperties.combine_neigh_count_Nv_general"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.combine_neigh_count_Nv_general">[docs]</a>    <span class="k">def</span> <span class="nf">combine_neigh_count_Nv_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_branch</span><span class="p">):</span>
        <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
        <span class="n">Nv_sum</span> <span class="o">+=</span> <span class="n">temp_branch</span><span class="o">.</span><span class="n">Nv</span>
        <span class="k">return</span> <span class="n">Nv_sum</span></div>

<div class="viewcode-block" id="TopGraphProperties.combine_neigh_count_Nv_VinB_general"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.combine_neigh_count_Nv_VinB_general">[docs]</a>    <span class="k">def</span> <span class="nf">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_branch</span><span class="p">):</span>
        <span class="n">V_in_branch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_general</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopGraphProperties.update_neigh_count_Nv_general"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.update_neigh_count_Nv_general">[docs]</a>    <span class="k">def</span> <span class="nf">update_neigh_count_Nv_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_branch</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">temp_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
        <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_neigh_count</span><span class="p">)</span>
        <span class="n">Nv_sum</span> <span class="o">+=</span> <span class="n">temp_branch</span><span class="o">.</span><span class="n">Nv</span>
        <span class="k">return</span> <span class="n">Nv_sum</span></div>

<div class="viewcode-block" id="TopGraphProperties.update_neigh_count_Nv_VinB_general"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.update_neigh_count_Nv_VinB_general">[docs]</a>    <span class="k">def</span> <span class="nf">update_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_branch</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">V_in_branch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_neigh_count_Nv_general</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_branch</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">)</span></div>

    <span class="c1">####################################################################################################################</span>
    <span class="c1">####################################################################################################################</span>
    <span class="c1">####################################################################################################################</span>
<div class="viewcode-block" id="TopGraphProperties.remove_V_in_branch"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.remove_V_in_branch">[docs]</a>    <span class="k">def</span> <span class="nf">remove_V_in_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">V_in_branch_empty</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">branches</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">temp_branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">temp_branch</span><span class="o">.</span><span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch_empty</span>
        <span class="k">for</span> <span class="n">branches</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">temp_branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">temp_branch</span><span class="o">.</span><span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch_empty</span>
                <span class="n">temp_branch</span><span class="o">.</span><span class="n">combined_linear_branch</span><span class="o">.</span><span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch_empty</span>
                <span class="k">for</span> <span class="n">temp_fake_branch</span> <span class="ow">in</span> <span class="n">temp_branch</span><span class="o">.</span><span class="n">fake_branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">temp_fake_branch</span><span class="o">.</span><span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch_empty</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_branches"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_branches">[docs]</a>    <span class="k">def</span> <span class="nf">get_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">:</span>
            <span class="n">temp_gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">BFS_l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flag_v_list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest</span> <span class="o">=</span>  <span class="nb">tuple</span><span class="p">(</span><span class="n">temp_gen</span><span class="p">)</span>
            <span class="n">temp_gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">BFS_l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flag_v_list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_int_sol</span> <span class="o">=</span>  <span class="nb">list</span><span class="p">(</span><span class="n">temp_gen</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_int_sol</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_int_sol</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_int_sol</span><span class="p">)</span>
            <span class="c1">#self.Vs_of_interest = self.Vs_of_int_sol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest</span> <span class="o">=</span>  <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_Vs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_int_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest</span>
        <span class="c1">#self.Vs_of_interest =  tuple(self.available_Vs)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_first_non_ring_neighbour</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dummy_branches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#for v0 in self.Vs_of_interest:</span>
        <span class="k">for</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_int_sol</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1">#        for v0 in self.Vs_of_interest:</span>
        <span class="k">for</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_int_sol</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_dummy_match_Vs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_dummy_branch</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_branch_recursive</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_nonring_branch_recursive</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_combined_linear_branch_tot_Nv</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_break_branches</span><span class="p">()</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_dummy_branch"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_dummy_branch">[docs]</a>    <span class="k">def</span> <span class="nf">get_dummy_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
            <span class="n">protected_Vs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
                    <span class="n">temp_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_solution_Vs</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">other_atom_in_r</span> <span class="o">=</span> <span class="n">temp_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">protected_Vs</span> <span class="o">=</span> <span class="n">protected_Vs</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">other_atom_in_r</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">ind_ring_part</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts_map</span><span class="p">[</span><span class="n">other_atom_in_r</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">v0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ind_ring_part</span><span class="p">:</span>
                                <span class="n">protected_Vs</span> <span class="o">=</span> <span class="n">protected_Vs</span> <span class="o">|</span> <span class="n">ind_ring_part</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="n">protected_Vs</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dummy_branches</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">_BFS</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">visited</span><span class="p">))[</span><span class="mi">1</span><span class="p">:]</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_nonring_branch_recursive"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_nonring_branch_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">get_nonring_branch_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">Nv_sum</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="n">v0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span>
                <span class="n">temp_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_branch_recursive</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_branch</span><span class="p">)</span><span class="c1">#####################</span>
        <span class="k">for</span> <span class="n">v_next</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v_next</span><span class="o">!=</span><span class="n">v0</span> <span class="ow">and</span> <span class="n">v_next</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_Vs</span><span class="p">:</span>
                <span class="n">temp_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nonring_branch_recursive</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v_next</span><span class="p">)</span>
                <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_branch</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="n">linear_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v0</span><span class="p">,),</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="p">),</span> <span class="n">b_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="n">linear_branch</span>
        <span class="k">return</span> <span class="n">linear_branch</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_ring_branch_recursive"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_ring_branch_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">get_ring_branch_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">r</span><span class="p">]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">(</span><span class="n">v0</span><span class="p">,)</span>
        <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_get_visited_from_roots_parents</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">ring_independent_parts_availability_map</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">)</span>
        <span class="n">temp_BFS</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">visited</span><span class="p">),</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># do ring_ring_branch</span>
        <span class="n">ring_ring_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_ring_branch_from_generator_VinB_recursive</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">temp_BFS</span><span class="p">)</span>
        <span class="c1"># do combined linear branch</span>
        <span class="n">ring_combined_linear_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_combined_linear_branch_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span>
        <span class="c1"># combine ring_ring and combined_linear into ring_branch</span>
        <span class="n">ring_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ring_branch_combine_ring_ring_linear</span><span class="p">(</span><span class="n">ring_ring_branch</span><span class="p">,</span> <span class="n">ring_combined_linear_branch</span><span class="p">)</span>
        <span class="c1"># do fake linear branches from each first neighbour within the ring</span>
        <span class="n">ring_branch</span><span class="o">.</span><span class="n">fake_branches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">ring_branch</span><span class="o">.</span><span class="n">ring_branch</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="n">temp_BFS</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">BFS</span><span class="p">([</span><span class="n">v1</span><span class="p">],</span> <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">visited</span><span class="p">),</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">fake_ring_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_ring_branch_from_generator_recursive</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="p">(</span><span class="n">v1</span><span class="p">,),</span> <span class="n">r</span><span class="p">,</span>
                                                                        <span class="n">ring_branch</span><span class="o">.</span><span class="n">ring_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">temp_BFS</span><span class="p">)</span>
                <span class="n">ring_branch</span><span class="o">.</span><span class="n">fake_branches</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fake_ring_branch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring_branch</span>
        <span class="k">return</span> <span class="n">ring_branch</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_ring_ring_branch_from_generator_VinB_recursive"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_ring_ring_branch_from_generator_VinB_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">get_ring_ring_branch_from_generator_VinB_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">BFS_generator</span><span class="p">):</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Nv_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">BFS_generator</span><span class="p">:</span>
            <span class="n">temp_comb_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_combined_FromRing_branch_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_comb_branch</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">b_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum</span><span class="p">)</span></div>

    <span class="c1"># same as above, just does not take care about V_in_branches - this is just copied</span>
<div class="viewcode-block" id="TopGraphProperties.get_ring_ring_branch_from_generator_recursive"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_ring_ring_branch_from_generator_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">get_ring_ring_branch_from_generator_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">BFS_generator</span><span class="p">):</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Nv_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">BFS_generator</span><span class="p">:</span>
            <span class="n">temp_comb_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_combined_FromRing_branch_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_neigh_count_Nv_general</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_comb_branch</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">b_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum</span><span class="p">)</span></div>

    <span class="c1"># this would be wrong as ring_combined_linear_branch assumes v0 -&gt; v1 + FromRing branches</span>
    <span class="c1"># so only atoms that have no neighbours in solution could be available for such branches</span>
    <span class="c1"># as it should be v0 and v1 bonded pair within the ring - which already gives 2 atoms</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def __get_flag_ring_combined_linear_branch(self, r, v):</span>
<span class="sd">        temp__in_sol__1st_neigh = self.in_solution_Vs &amp; set(r.adj[v])</span>
<span class="sd">        if temp__in_sol__1st_neigh:</span>
<span class="sd">            if len(temp__in_sol__1st_neigh) == 1:</span>
<span class="sd">                for temp_v in temp__in_sol__1st_neigh:</span>
<span class="sd">                    if not self.in_solution_Vs &amp; set(r.adj[temp_v]):</span>
<span class="sd">                        return True</span>
<span class="sd">        else:</span>
<span class="sd">            return True</span>
<span class="sd">        return False</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TopGraphProperties.get_ring_combined_linear_branch_recursive"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_ring_combined_linear_branch_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">get_ring_combined_linear_branch_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Nv_max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_solution_Vs</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]):</span> <span class="c1"># ring_combined_linear_branch assumes v0 -&gt; v1 + FromRing branches</span>
            <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_Vs</span><span class="p">:</span>
                    <span class="n">parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
                    <span class="n">temp_FromRing_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_combined_FromRing_branch_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
                    <span class="n">neigh_count_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_FromRing_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">)</span>
                    <span class="n">V_in_branch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_FromRing_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">Nv_max</span> <span class="o">&lt;</span> <span class="n">temp_FromRing_branch</span><span class="o">.</span><span class="n">Nv</span><span class="p">:</span>
                        <span class="n">Nv_max</span> <span class="o">=</span> <span class="n">temp_FromRing_branch</span><span class="o">.</span><span class="n">Nv</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parents</span><span class="p">:</span>
            <span class="n">combined_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">combine_mutually_exclusive_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">combined_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">return</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v</span><span class="p">,),</span> <span class="n">parents</span><span class="p">,</span> <span class="n">combined_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_max</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_ring_combined_FromRing_branch_recursive"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_ring_combined_FromRing_branch_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">get_ring_combined_FromRing_branch_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">Nv_sum</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">temp_branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_FromRing_branches_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">temp_branch</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="n">b_neigh_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">b_neigh_count</span><span class="p">)</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">)</span>
        <span class="n">combined_FromRing_b</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]),</span> <span class="p">(</span><span class="n">v</span><span class="p">,),</span> <span class="n">b_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_FromRing_b</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v</span><span class="p">]</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_ring_branch_combine_ring_ring_linear</span><span class="p">(</span><span class="n">ring_ring_branch</span><span class="p">,</span> <span class="n">ring_combined_linear_branch</span><span class="p">):</span>
        <span class="n">combined_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">combine_mutually_exclusive_neigh_count_list</span><span class="p">((</span><span class="n">ring_ring_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">,</span>
                                                                            <span class="n">ring_combined_linear_branch</span><span class="o">.</span><span class="n">neigh_count</span><span class="p">))</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">ring_ring_branch</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">ring_combined_linear_branch</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">ring_ring_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">ring_combined_linear_branch</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
        <span class="n">Nv_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ring_ring_branch</span><span class="o">.</span><span class="n">Nv</span><span class="p">,</span> <span class="n">ring_combined_linear_branch</span><span class="o">.</span><span class="n">Nv</span><span class="p">)</span>
        <span class="n">ring_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">(</span><span class="n">ring_ring_branch</span><span class="o">.</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">combined_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_max</span><span class="p">)</span>
        <span class="n">ring_branch</span><span class="o">.</span><span class="n">ring_branch</span><span class="p">,</span> <span class="n">ring_branch</span><span class="o">.</span><span class="n">combined_linear_branch</span> <span class="o">=</span> <span class="n">ring_ring_branch</span><span class="p">,</span> <span class="n">ring_combined_linear_branch</span>
        <span class="k">return</span> <span class="n">ring_branch</span>

<div class="viewcode-block" id="TopGraphProperties.get_ring_combined_linear_branch_tot_Nv"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_ring_combined_linear_branch_tot_Nv">[docs]</a>    <span class="k">def</span> <span class="nf">get_ring_combined_linear_branch_tot_Nv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">:</span>
            <span class="c1">#if v not in self.Vs_of_interest:continue</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_int_sol</span><span class="p">:</span><span class="k">continue</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">ring_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">r</span><span class="p">]</span>
                <span class="n">combined_linear_branch</span> <span class="o">=</span> <span class="n">ring_branch</span><span class="o">.</span><span class="n">combined_linear_branch</span>
                <span class="n">temp_FromRing_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_combined_FromRing_branch_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">combined_linear_branch</span><span class="o">.</span><span class="n">tot_Nv</span> <span class="o">=</span> <span class="n">combined_linear_branch</span><span class="o">.</span><span class="n">Nv</span> <span class="o">+</span> <span class="n">temp_FromRing_branch</span><span class="o">.</span><span class="n">Nv</span><span class="c1"># - 1 (this minus one is actually not wrong, but we use this to get to the total number of atoms, including the roots...)</span></div>

    <span class="c1"># ring break branches</span>
<div class="viewcode-block" id="TopGraphProperties.get_ring_break_branches"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_ring_break_branches">[docs]</a>    <span class="k">def</span> <span class="nf">get_ring_break_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">break_branches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">break_branches</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">temp_break</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">break_parents</span><span class="p">:</span>
                <span class="n">temp_break_branches</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">parents</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">break_parents</span><span class="p">[</span><span class="n">temp_break</span><span class="p">]:</span>
                    <span class="n">temp_gen</span><span class="p">,</span> <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_get_BFS_generator_roots_parents_non__available_Vs</span><span class="p">(</span><span class="n">temp_break</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span>
                                            <span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_independent_parts_availability_map</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_available_Vs</span><span class="p">)</span>
                    <span class="n">temp_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_ring_branch_from_generator_VinB_recursive</span><span class="p">(</span><span class="n">temp_break</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">temp_gen</span><span class="p">)</span>
                    <span class="n">temp_branch</span><span class="o">.</span><span class="n">tot_Nv</span> <span class="o">=</span> <span class="n">temp_branch</span><span class="o">.</span><span class="n">Nv</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp_branch</span><span class="o">.</span><span class="n">roots</span><span class="p">:</span>
                        <span class="n">FromRing_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_combined_FromRing_branch_recursive</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                        <span class="n">temp_branch</span><span class="o">.</span><span class="n">tot_Nv</span> <span class="o">+=</span> <span class="n">FromRing_b</span><span class="o">.</span><span class="n">Nv</span>
                    <span class="n">temp_break_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_branch</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">break_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">temp_break</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_break_branches</span></div>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions ##</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions ##</span>
    <span class="c1">####################################################################################################################</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_r_get_visited_from_roots_parents</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">independent_parts_availability_map</span><span class="p">,</span> <span class="n">non_available_Vs</span><span class="p">):</span>
        <span class="n">initial_ind_parts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ind_part</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts_map</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">independent_parts_availability_map</span><span class="p">[</span><span class="n">ind_part</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ind_part</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">initial_ind_parts</span><span class="p">:</span>
                    <span class="n">initial_ind_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind_part</span><span class="p">)</span>
        <span class="n">visited_ind_parts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ind_part</span> <span class="k">for</span> <span class="n">ind_part</span> <span class="ow">in</span> <span class="n">independent_parts_availability_map</span>
                             <span class="k">if</span> <span class="ow">not</span> <span class="n">independent_parts_availability_map</span><span class="p">[</span><span class="n">ind_part</span><span class="p">])</span> <span class="c1"># all ind parts that are not available</span>
        <span class="n">available_Vs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ind_part</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts_graph</span><span class="o">.</span><span class="n">_BFS</span><span class="p">(</span><span class="n">initial_ind_parts</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">visited_ind_parts</span><span class="p">,</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">available_Vs</span> <span class="o">=</span> <span class="n">available_Vs</span> <span class="o">|</span> <span class="n">ind_part</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span> <span class="o">-</span> <span class="n">available_Vs</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">|</span> <span class="n">non_available_Vs</span>
        <span class="k">return</span> <span class="n">visited</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">-</span> <span class="n">visited</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_r_get_BFS_generator_roots_parents_non__available_Vs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">independent_parts_availability_map</span><span class="p">,</span>
                                                             <span class="n">non_available_Vs</span><span class="p">):</span>
        <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_r_get_visited_from_roots_parents</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">independent_parts_availability_map</span><span class="p">,</span>
                                                                 <span class="n">non_available_Vs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">BFS</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">visited</span><span class="p">,</span> <span class="n">flag_v_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">),</span> <span class="n">parents</span>

<div class="viewcode-block" id="TopGraphProperties.get_FromRing_branches_recursive"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_FromRing_branches_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">get_FromRing_branches_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ring_outside_r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">ring_outside_r</span> <span class="o">!=</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_branch_recursive</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ring_outside_r</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v_outside_r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nonring_branch_recursive</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v_outside_r</span><span class="p">)</span></div>

    <span class="c1"># same as above, but split...</span>
<div class="viewcode-block" id="TopGraphProperties.get_FromRing_ring_branches_recursive"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_FromRing_ring_branches_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">get_FromRing_ring_branches_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ring_outside_r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">ring_outside_r</span> <span class="o">!=</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_branch_recursive</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ring_outside_r</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_FromRing_nonring_branches_recursive"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_FromRing_nonring_branches_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">get_FromRing_nonring_branches_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v_outside_r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_non_ring_neighbours</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nonring_branch_recursive</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v_outside_r</span><span class="p">)</span></div>

    <span class="c1">####################################################################################################################</span>
    <span class="c1">####################################################################################################################</span>

    <span class="c1"># combined branches</span>
    <span class="k">def</span> <span class="nf">_get_combined_neigh_count_Nv_allowed_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">allowed_parents</span><span class="p">):</span>
        <span class="n">Nv_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">allowed_parents</span><span class="p">:</span>
                <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="n">parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
            <span class="n">Nv_sum_lin</span> <span class="o">=</span> <span class="n">Nv_sum</span>
            <span class="n">neigh_count_list_lin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
            <span class="n">V_in_branch_lin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">)</span>
            <span class="n">parents_lin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">flag_parents_in_allowed</span> <span class="o">=</span> <span class="kc">True</span><span class="c1">############## check DEBUGGING</span>
                <span class="n">flag_1_parent_in_allowed</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">temp_parent</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">temp_parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_parents</span><span class="p">:</span>
                        <span class="n">flag_parents_in_allowed</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">flag_parents_in_allowed</span><span class="p">:</span>
                    <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                    <span class="n">parents</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
                    <span class="n">Nv_sum_lin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch_lin</span><span class="p">,</span> <span class="n">neigh_count_list_lin</span><span class="p">,</span>
                                                                          <span class="n">Nv_sum_lin</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">combined_linear_branch</span><span class="p">)</span>
                    <span class="n">parents_lin</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">combined_linear_branch</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">temp_parent</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">temp_parent</span> <span class="ow">in</span> <span class="n">allowed_parents</span><span class="p">:</span>
                            <span class="n">fake_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">fake_branches</span><span class="p">[</span><span class="n">temp_parent</span><span class="p">]</span>
                            <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">fake_b</span><span class="p">)</span>
                            <span class="n">parents</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fake_b</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
                            <span class="n">Nv_sum_lin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch_lin</span><span class="p">,</span> <span class="n">neigh_count_list_lin</span><span class="p">,</span>
                                                                                  <span class="n">Nv_sum_lin</span><span class="p">,</span> <span class="n">fake_b</span><span class="p">)</span>
                            <span class="n">parents_lin</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">combined_linear_branch</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
            <span class="n">temp_neigh_count_lin</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list_lin</span><span class="p">)</span>
            <span class="n">ring_linear_combined_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v</span><span class="p">,),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parents_lin</span><span class="p">),</span> <span class="n">temp_neigh_count_lin</span><span class="p">,</span>
                                                           <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch_lin</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum_lin</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ring_linear_combined_branch</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
        <span class="n">combined_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v</span><span class="p">,),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parents</span><span class="p">),</span> <span class="n">temp_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum</span><span class="p">)</span>
        <span class="n">combined_branch</span><span class="o">.</span><span class="n">ring_linear_combined_branch</span> <span class="o">=</span> <span class="n">ring_linear_combined_branch</span>
        <span class="k">return</span> <span class="n">combined_branch</span>

<div class="viewcode-block" id="TopGraphProperties.get_combined_neigh_count_Nv"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_combined_neigh_count_Nv">[docs]</a>    <span class="k">def</span> <span class="nf">get_combined_neigh_count_Nv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#for v in self.Vs_of_interest:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_int_sol</span><span class="p">:</span> <span class="c1"># combined list of Vs of int and in sol Vs</span>
            <span class="n">Nv_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">neigh_count_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">V_in_branch</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="n">parents</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
            <span class="c1"># splitting the combined branch in ring and linear</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
                <span class="n">Nv_sum_lin</span> <span class="o">=</span> <span class="n">Nv_sum</span>
                <span class="n">neigh_count_list_lin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
                <span class="n">V_in_branch_lin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">)</span>
                <span class="n">parents_lin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">Nv_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch</span><span class="p">,</span> <span class="n">neigh_count_list</span><span class="p">,</span> <span class="n">Nv_sum</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                    <span class="n">parents</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
                    <span class="n">Nv_sum_lin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_neigh_count_Nv_VinB_general</span><span class="p">(</span><span class="n">V_in_branch_lin</span><span class="p">,</span> <span class="n">neigh_count_list_lin</span><span class="p">,</span>
                                                                          <span class="n">Nv_sum_lin</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">combined_linear_branch</span><span class="p">)</span>
                    <span class="n">parents_lin</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">combined_linear_branch</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
                <span class="n">temp_neigh_count_lin</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list_lin</span><span class="p">)</span>
                <span class="n">ring_linear_combined_branch</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v</span><span class="p">,),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parents_lin</span><span class="p">),</span> <span class="n">temp_neigh_count_lin</span><span class="p">,</span>
                                                               <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch_lin</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum_lin</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ring_linear_combined_branch</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">temp_neigh_count</span> <span class="o">=</span> <span class="n">Branch</span><span class="o">.</span><span class="n">sum_neigh_count_list</span><span class="p">(</span><span class="n">neigh_count_list</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">((</span><span class="n">v</span><span class="p">,),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parents</span><span class="p">),</span> <span class="n">temp_neigh_count</span><span class="p">,</span> <span class="n">V_in_branch</span> <span class="o">=</span> <span class="n">V_in_branch</span><span class="p">,</span> <span class="n">Nv</span> <span class="o">=</span> <span class="n">Nv_sum</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">ring_linear_combined_branch</span> <span class="o">=</span> <span class="n">ring_linear_combined_branch</span></div>

    <span class="c1">################ separate groups</span>
<div class="viewcode-block" id="TopGraphProperties.get_separate_groups_brute_force"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_separate_groups_brute_force">[docs]</a>    <span class="k">def</span> <span class="nf">get_separate_groups_brute_force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)):</span>
                <span class="n">temp_grp</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">grp</span> <span class="o">==</span> <span class="n">temp_grp</span><span class="p">:</span>
                    <span class="n">grp</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span>
                <span class="n">common</span> <span class="o">=</span> <span class="n">grp</span> <span class="o">&amp;</span> <span class="n">temp_grp</span>
                <span class="k">if</span> <span class="n">common</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">common</span> <span class="o">!=</span> <span class="n">temp_grp</span><span class="p">:</span>
                        <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_grp</span> <span class="o">-</span> <span class="n">grp</span>
                    <span class="k">if</span> <span class="n">common</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">common</span><span class="p">)</span>
                    <span class="n">grp</span> <span class="o">=</span> <span class="n">grp</span> <span class="o">-</span> <span class="n">temp_grp</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">grp</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">grp</span><span class="p">:</span>
                <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_separate_groups</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groups</span></div>

    <span class="k">def</span> <span class="nf">__get_tgp_no_dummies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TopGraphProperties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">available_Vs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">available_Vs</span><span class="p">,</span> <span class="n">in_solution_Vs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">)</span>

<div class="viewcode-block" id="TopGraphProperties.get_separate_groups"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_separate_groups">[docs]</a>    <span class="k">def</span> <span class="nf">get_separate_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">tgp_no_dummies</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tgp_no_dummies&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tgp_no_dummies</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_dummy_match_Vs</span><span class="p">:</span>
                <span class="n">tgp_no_dummies</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tgp_no_dummies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_tgp_no_dummies</span><span class="p">()</span>
        <span class="c1">#in_solution_Vs_groups = {}</span>
        <span class="n">parents__common_Vs_of_interest_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#groups = {}</span>
        <span class="n">Vs_of_interest__in_solution_Vs_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">Vs_of_interest</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest</span><span class="p">)</span>
        <span class="n">in_solution_Vs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_solution_Vs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">temp_parent</span> <span class="ow">in</span> <span class="n">Vs_of_interest</span><span class="p">:</span>
            <span class="n">common_Vs_in_sol</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">BFS_l</span><span class="p">(</span><span class="n">temp_parent</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">in_solution_Vs</span>
            <span class="n">Vs_of_interest__in_solution_Vs_map</span><span class="p">[</span><span class="n">temp_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_Vs_in_sol</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            if common_Vs_in_sol not in in_solution_Vs_groups:</span>
<span class="sd">                in_solution_Vs_groups[common_Vs_in_sol] = [temp_parent]</span>
<span class="sd">            else:</span>
<span class="sd">                in_solution_Vs_groups[common_Vs_in_sol].append(temp_parent)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">temp_parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parents__common_Vs_of_interest_map</span><span class="p">:</span>
                <span class="n">temp_group</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">temp_parent</span><span class="p">]</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span> <span class="o">|</span> <span class="p">{</span><span class="n">temp_parent</span><span class="p">}</span>
                <span class="n">common_Vs_of_interest</span> <span class="o">=</span> <span class="n">temp_group</span> <span class="o">&amp;</span> <span class="n">Vs_of_interest</span>
                <span class="k">for</span> <span class="n">temp_temp_parent</span> <span class="ow">in</span> <span class="n">common_Vs_of_interest</span><span class="p">:</span>
                    <span class="n">parents__common_Vs_of_interest_map</span><span class="p">[</span><span class="n">temp_temp_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_Vs_of_interest</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                temp_group_ND = frozenset(tgp_no_dummies.combined_branches[temp_parent].V_in_branch) | {temp_parent}</span>
<span class="sd">                common_Vs_of_interest_ND = temp_group_ND &amp; Vs_of_interest</span>
<span class="sd">                groups[common_Vs_of_interest_ND] = temp_group_ND</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="n">groups4estimates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">shared_Vs_in_sol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_solution_Vs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">temp_parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="n">common_Vs_in_sol</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span>
                <span class="n">common_Vs_of_interest</span> <span class="o">=</span> <span class="n">parents__common_Vs_of_interest_map</span><span class="p">[</span><span class="n">temp_parent</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">temp_temp_parent</span> <span class="ow">in</span> <span class="n">common_Vs_of_interest</span><span class="p">:</span>
                    <span class="n">common_Vs_in_sol</span> <span class="o">|=</span> <span class="n">Vs_of_interest__in_solution_Vs_map</span><span class="p">[</span><span class="n">temp_temp_parent</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">common_Vs_in_sol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groups4estimates</span><span class="p">:</span>
                    <span class="n">groups4estimates</span><span class="p">[</span><span class="n">common_Vs_in_sol</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_Vs_of_interest</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">groups4estimates</span><span class="p">[</span><span class="n">common_Vs_in_sol</span><span class="p">]</span> <span class="o">|=</span> <span class="n">common_Vs_of_interest</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_Vs_in_sol</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">shared_Vs_in_sol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">common_Vs_in_sol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents__common_Vs_of_interest_map</span> <span class="o">=</span> <span class="n">parents__common_Vs_of_interest_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest__in_solution_Vs_map</span> <span class="o">=</span> <span class="n">Vs_of_interest__in_solution_Vs_map</span>
        <span class="c1">#self.groups = groups</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared_Vs_in_sol</span> <span class="o">=</span> <span class="n">shared_Vs_in_sol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups4estimates</span> <span class="o">=</span> <span class="n">groups4estimates</span>
        <span class="c1">#assert self.check_separate_groups(groups.values())################## this should be removed, debugging</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups4estimates</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_separate_groups_old"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_separate_groups_old">[docs]</a>    <span class="k">def</span> <span class="nf">get_separate_groups_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">#return</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">groups_Vs_of_interest</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">Vs_of_interest</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest</span><span class="p">)</span>
        <span class="n">parents_done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
            <span class="n">common_Vs_of_interest</span> <span class="o">=</span> <span class="n">grp</span> <span class="o">&amp;</span> <span class="n">Vs_of_interest</span>
            <span class="n">N_common_Vs_of_interest</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_Vs_of_interest</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">N_common_Vs_of_interest</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">grp</span> <span class="o">==</span> <span class="n">common_Vs_of_interest</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">grp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                        <span class="n">groups</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
                        <span class="n">groups_Vs_of_interest</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_Vs_of_interest</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">groups</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">groups_Vs_of_interest</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups_Vs_of_interest</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">|</span> <span class="n">common_Vs_of_interest</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
                    <span class="n">groups_Vs_of_interest</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_Vs_of_interest</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">temp_parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">temp_parent</span> <span class="ow">in</span> <span class="n">parents_done</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">temp_group</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">temp_parent</span><span class="p">]</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
                    <span class="n">other_parents</span> <span class="o">=</span> <span class="n">temp_group</span> <span class="o">&amp;</span> <span class="n">common_Vs_of_interest</span>
                    <span class="n">temp_group</span> <span class="o">=</span> <span class="n">temp_group</span> <span class="o">|</span> <span class="p">{</span><span class="n">temp_parent</span><span class="p">}</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">other_parents</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">temp_group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                            <span class="n">groups</span><span class="p">[</span><span class="n">temp_group</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
                            <span class="n">groups_Vs_of_interest</span><span class="p">[</span><span class="n">temp_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_Vs_of_interest</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">groups</span><span class="p">[</span><span class="n">temp_group</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                            <span class="n">groups_Vs_of_interest</span><span class="p">[</span><span class="n">temp_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups_Vs_of_interest</span><span class="p">[</span><span class="n">temp_group</span><span class="p">]</span> <span class="o">|</span> <span class="n">common_Vs_of_interest</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">groups</span><span class="p">[</span><span class="n">temp_group</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
                        <span class="c1">#groups[temp_group].extend(other_parents) # missing the roots actually</span>
                        <span class="n">groups_Vs_of_interest</span><span class="p">[</span><span class="n">temp_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_Vs_of_interest</span>
                    <span class="k">for</span> <span class="n">other_parent</span> <span class="ow">in</span> <span class="n">other_parents</span><span class="p">:</span>
                        <span class="n">other_temp_group</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">other_parent</span><span class="p">]</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span> <span class="o">|</span> <span class="p">{</span><span class="n">other_parent</span><span class="p">}</span>
                        <span class="k">assert</span> <span class="n">temp_group</span> <span class="o">==</span> <span class="n">other_temp_group</span>
                    <span class="n">parents_done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">temp_parent</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">parents_done</span> <span class="o">&amp;</span> <span class="n">other_parents</span>
                    <span class="n">parents_done</span> <span class="o">=</span> <span class="n">parents_done</span> <span class="o">|</span> <span class="n">other_parents</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_separate_groups</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="c1">################## this should be removes, debugging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">groups</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups_Vs_of_interest</span> <span class="o">=</span> <span class="n">groups_Vs_of_interest</span>
        <span class="k">return</span> <span class="n">groups</span></div>

<div class="viewcode-block" id="TopGraphProperties.check_separate_groups"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.check_separate_groups">[docs]</a>    <span class="k">def</span> <span class="nf">check_separate_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">tgp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_tgp_no_dummies</span><span class="p">()</span>
        <span class="n">Vs_all1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">:</span>
            <span class="n">Vs_all1</span> <span class="o">=</span> <span class="n">Vs_all1</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">tgp</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">V_in_branch</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">groups</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">Vs_all1</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">Vs_all2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">grp1</span><span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">Vs_all2</span> <span class="o">=</span> <span class="n">Vs_all2</span> <span class="o">|</span> <span class="n">grp1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
                <span class="n">grp2</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">grp1</span> <span class="o">&amp;</span> <span class="n">grp2</span>
        <span class="n">Vs_all2</span> <span class="o">=</span> <span class="n">Vs_all2</span> <span class="o">|</span> <span class="n">groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">Vs_all1</span> <span class="o">==</span> <span class="n">Vs_all2</span>
        <span class="k">assert</span> <span class="n">Vs_all1</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_solution_Vs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="c1">####################################################################################################################</span>
    <span class="c1">####################################################################################################################</span>

    <span class="c1"># dummy estimates</span>
<div class="viewcode-block" id="TopGraphProperties.get_dummy_match_estimates_in_solution"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_dummy_match_estimates_in_solution">[docs]</a>    <span class="k">def</span> <span class="nf">get_dummy_match_estimates_in_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dummy_estimates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest</span><span class="p">:</span>
            <span class="n">anchor_atoms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_solution_Vs</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">anchor_atoms</span><span class="p">)</span> <span class="o">==</span>  <span class="mi">1</span><span class="p">:</span>
                <span class="n">anchor_atom</span> <span class="o">=</span> <span class="n">anchor_atoms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">max_Nv_Vother_branches</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">v_other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">anchor_atom</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">v_other</span><span class="o">==</span><span class="n">v</span> <span class="ow">or</span> <span class="n">v_other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest</span><span class="p">:</span><span class="k">continue</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
                        <span class="n">Nv4comparison</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v_other</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">v_other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">:</span>
                        <span class="n">Nv4comparison</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v_other</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">common_ring</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">rings_map</span><span class="p">[</span><span class="n">v_other</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">common_ring</span><span class="p">:</span>
                            <span class="n">common_ring</span> <span class="o">=</span> <span class="n">common_ring</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">common_ring</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_solution_Vs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">assert</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">common_ring</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_solution_Vs</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">==</span> <span class="n">anchor_atom</span>
                                <span class="k">if</span> <span class="n">anchor_atom</span> <span class="ow">in</span> <span class="n">common_ring</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">v_other</span> <span class="ow">in</span> <span class="n">common_ring</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">[</span><span class="n">anchor_atom</span><span class="p">]:</span>
                                        <span class="k">for</span> <span class="n">break_branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">break_branches</span><span class="p">[</span><span class="n">common_ring</span><span class="p">][</span><span class="n">common_ring</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">[</span><span class="n">anchor_atom</span><span class="p">]]:</span>
                                            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">break_branch</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                                                <span class="n">Nv4comparison</span> <span class="o">=</span> <span class="n">break_branch</span><span class="o">.</span><span class="n">Nv</span> <span class="o">+</span> \
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">common_ring</span><span class="p">][</span><span class="n">v_other</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">Nv4comparison</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">common_ring</span><span class="p">][</span><span class="n">v_other</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">Nv4comparison</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">common_ring</span><span class="p">][</span><span class="n">v_other</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">Nv4comparison</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">Nv4comparison</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v_other</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">max_Nv_Vother_branches</span> <span class="o">&lt;</span> <span class="n">Nv4comparison</span><span class="p">:</span>
                        <span class="n">max_Nv_Vother_branches</span> <span class="o">=</span> <span class="n">Nv4comparison</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dummy_estimates</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_Nv_Vother_branches</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dummy_estimates</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_dummy_match_estimates"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_dummy_match_estimates">[docs]</a>    <span class="k">def</span> <span class="nf">get_dummy_match_estimates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted_combined_branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sorted_combined_branches</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dummy_estimates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted_RLCBs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># sorted_RLCBs is sorted_ring_linear_combined_branches, it&#39;s called when needed</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest</span><span class="p">:</span>
<span class="c1">#            if v in self.non_available_Vs:continue # is this needed at all?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dummy_estimates</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_v_dummy_match_estimate</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_v_dummy_match_estimate"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_v_dummy_match_estimate">[docs]</a>    <span class="k">def</span> <span class="nf">get_v_dummy_match_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_dummy</span><span class="p">):</span>
        <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_Nv_combB_vDummy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">temp_combined_branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_combined_branches</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">temp_combined_branch</span><span class="o">.</span><span class="n">Nv</span> <span class="o">&lt;</span> <span class="n">max_Nv_neigh_branches</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">max_Nv_neigh_branches</span>
            <span class="k">if</span> <span class="n">v_dummy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">temp_combined_branch</span><span class="o">.</span><span class="n">V_in_branch</span> <span class="ow">and</span> <span class="n">v_dummy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">temp_combined_branch</span><span class="o">.</span><span class="n">roots</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">temp_combined_branch</span><span class="o">.</span><span class="n">Nv</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># this is already max(temp_branch.Nv, temp_max_Nv), if above</span>
            <span class="k">elif</span> <span class="n">max_Nv_combB_vDummy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_Nv_combB_vDummy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_Nv_combB_vDummy</span><span class="p">(</span><span class="n">v_dummy</span><span class="p">)</span>
                <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_Nv_neigh_branches</span><span class="p">,</span> <span class="n">max_Nv_combB_vDummy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">max_Nv_neigh_branches</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_max_Nv_combB_vDummy"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_max_Nv_combB_vDummy">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_Nv_combB_vDummy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">sorted_RLCB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ring_sorted_RLCB</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">Vs_independent</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">temp_ind_ring_part</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">independent_parts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp_ind_ring_part</span><span class="p">:</span> <span class="c1"># finding independent ring parts with this atom</span>
                    <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">temp_ind_ring_part</span><span class="p">:</span> <span class="c1"># looping over each atom of the independent part</span>
                        <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_Vs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
                                    <span class="k">for</span> <span class="n">break_branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">break_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">r</span><span class="o">.</span><span class="n">breaks_map</span><span class="p">[</span><span class="n">v1</span><span class="p">]]:</span>
                                        <span class="k">if</span> <span class="n">break_branch</span><span class="o">.</span><span class="n">parents</span> <span class="ow">and</span> <span class="n">break_branch</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">temp_ind_ring_part</span><span class="p">:</span>
                                            <span class="k">if</span> <span class="n">max_Nv_neigh_branches</span> <span class="o">&lt;</span> <span class="n">break_branch</span><span class="o">.</span><span class="n">tot_Nv</span><span class="p">:</span>
                                                <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="n">break_branch</span><span class="o">.</span><span class="n">tot_Nv</span>
                            <span class="k">if</span> <span class="n">v1</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_independent_parts_availability_map</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">temp_ind_ring_part</span><span class="p">]:</span>
                                    <span class="n">Vs_independent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
                                <span class="k">elif</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                                    <span class="n">Vs_independent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
            <span class="n">temp_max_Nv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_get_max_Nv_ring_linear_combined_branch</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">Vs_independent</span><span class="p">,</span> <span class="n">sorted_RLCB</span><span class="p">,</span>
                                                                       <span class="bp">self</span><span class="o">.</span><span class="n">combined_FromRing_branches</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_Nv_neigh_branches</span> <span class="o">&lt;</span> <span class="n">temp_max_Nv</span><span class="p">:</span>
                <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="n">temp_max_Nv</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">Nv</span> <span class="o">&gt;</span> <span class="n">max_Nv_neigh_branches</span><span class="p">:</span>
                <span class="n">max_Nv_neigh_branches</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">Nv</span>
        <span class="k">return</span> <span class="n">max_Nv_neigh_branches</span></div>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions ##</span>
    <span class="c1"># helper functions # helper functions # helper functions # helper functions # helper functions # helper functions ##</span>
    <span class="c1">####################################################################################################################</span>

<div class="viewcode-block" id="TopGraphProperties.get_sorted_combined_branches"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_sorted_combined_branches">[docs]</a>    <span class="k">def</span> <span class="nf">get_sorted_combined_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#temp_list = [self.combined_branches[v] for v in self.available_Vs]</span>
        <span class="n">temp_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_branches</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs_of_interest</span><span class="p">]</span>
        <span class="n">temp_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">Nv</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp_list</span></div>

<div class="viewcode-block" id="TopGraphProperties.get_ring_sorted_RLCB"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.TopGraphProperties.get_ring_sorted_RLCB">[docs]</a>    <span class="k">def</span> <span class="nf">get_ring_sorted_RLCB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_RLCBs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sorted_RLCBs</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_get_sorted_ring_linear_combined_branches</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_branches</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_Vs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_RLCBs</span><span class="p">[</span><span class="n">r</span><span class="p">]</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_r_get_sorted_ring_linear_combined_branches</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">ring_branches</span><span class="p">,</span> <span class="n">available_Vs</span><span class="p">,</span> <span class="n">Vs_subset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">Vs_subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Vs_subset</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">adj</span>
        <span class="n">temp_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ring_branches</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">combined_linear_branch</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Vs_subset</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">available_Vs</span><span class="p">]</span>
        <span class="n">temp_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">tot_Nv</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp_list</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_r_get_max_Nv_ring_linear_combined_branch</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v_dummy</span><span class="p">,</span> <span class="n">Vs_independent</span><span class="p">,</span> <span class="n">sorted_RLCB</span><span class="p">,</span> <span class="n">combined_FromRing_branches</span><span class="p">):</span>
        <span class="c1"># sorted_RLCB is sorted_ring_linear_combined_branches</span>
        <span class="n">temp_Nv_max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">sorted_RLCB</span><span class="p">:</span>
            <span class="c1"># b.roots[0] is the root vertex</span>
            <span class="c1"># and we are looking for its linear_combined + FromRing (tot_Nv)</span>
            <span class="c1"># if v_dummy is its parents, we have to recalculate it</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Vs_independent</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">temp_Nv_max</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">.</span><span class="n">tot_Nv</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">temp_Nv_max</span>
                <span class="k">if</span> <span class="n">v_dummy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span> <span class="c1"># this has to be done on the level of rings and with this if, since a vertex can be involved in more ind parts</span>
                    <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">tot_Nv</span> <span class="c1"># this is already max(b.Nv, temp_Nv_max)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Nv_max</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">v1</span><span class="o">!=</span><span class="n">v_dummy</span> <span class="ow">and</span> <span class="n">Nv_max</span> <span class="o">&lt;</span> <span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span><span class="p">:</span>
                            <span class="n">Nv_max</span> <span class="o">=</span> <span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span><span class="o">.</span><span class="n">Nv</span>
                    <span class="n">Nv_max</span> <span class="o">+=</span> <span class="n">combined_FromRing_branches</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">b</span><span class="o">.</span><span class="n">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">Nv</span>
                    <span class="n">temp_Nv_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp_Nv_max</span><span class="p">,</span> <span class="n">Nv_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp_Nv_max</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1">####################################################################################################################</span>
    <span class="c1"># allowing for non__available_Vs # allowing for non__available_Vs # allowing for non__available_Vs # allowing for non__available_Vs #</span>
    <span class="c1"># allowing for non__available_Vs # allowing for non__available_Vs # allowing for non__available_Vs # allowing for non__available_Vs #</span>
    <span class="c1"># allowing for non__available_Vs # allowing for non__available_Vs # allowing for non__available_Vs # allowing for non__available_Vs #</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    @staticmethod</span>
<span class="sd">    def _g_get_rings_available_Vs(g, available_Vs = None, non_available_Vs = None, flag_root_at=False):</span>
<span class="sd">        if available_Vs:</span>
<span class="sd">            available_Vs = list(available_Vs)</span>
<span class="sd">        elif non_available_Vs:</span>
<span class="sd">            available_Vs = list(set(g.adj) - set(non_available_Vs))</span>
<span class="sd">        else:</span>
<span class="sd">            available_Vs = list(g.adj)</span>
<span class="sd">        sub_graph_rings = []</span>
<span class="sd">        sub_graphs = []</span>
<span class="sd">        while available_Vs:</span>
<span class="sd">            v = available_Vs.pop()</span>
<span class="sd">            rings = []</span>
<span class="sd">            sub_graph_rings.append(rings)</span>
<span class="sd">            sub_graphs.append([v])</span>
<span class="sd">            path = [v]</span>
<span class="sd">            stack = []</span>
<span class="sd">            for i in g.adj[v]:</span>
<span class="sd">                stack.append((i, 1))</span>
<span class="sd">            while stack:</span>
<span class="sd">                cur, l = stack.pop()</span>
<span class="sd">                path = path[:l]</span>
<span class="sd">                if cur in available_Vs:</span>
<span class="sd">                    sub_graphs[-1].append(cur)</span>
<span class="sd">                    path.append(cur)</span>
<span class="sd">                    available_Vs.remove(cur)</span>
<span class="sd">                    for i in g.adj[cur]:</span>
<span class="sd">                        if i != path[-2]:</span>
<span class="sd">                            stack.append((i, l + 1))</span>
<span class="sd">                elif cur in path:</span>
<span class="sd">                    new_ring = []</span>
<span class="sd">                    for j in reversed(path):</span>
<span class="sd">                        for r_i in range(len(rings)):</span>
<span class="sd">                            if j in rings[r_i]:</span>
<span class="sd">                                if flag_root_at and len(set(rings[r_i]) &amp; set(path)) &lt; 2:</span>
<span class="sd">                                    continue</span>
<span class="sd">                                rings[r_i].extend(new_ring)</span>
<span class="sd">                                new_ring = rings.pop(r_i)</span>
<span class="sd">                                break</span>
<span class="sd">                        if j not in new_ring:</span>
<span class="sd">                            new_ring.append(j)</span>
<span class="sd">                        if j == cur:</span>
<span class="sd">                            break</span>
<span class="sd">                    rings.append(new_ring)</span>
<span class="sd">        return sub_graphs, sub_graph_rings</span>
<span class="sd">    &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="AlchemicalSolution_base"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base">[docs]</a><span class="k">class</span> <span class="nc">AlchemicalSolution_base</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tops</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">available_atoms</span><span class="p">,</span> <span class="n">flag_top_not_in_sol</span><span class="p">,</span> <span class="n">sol_atoms_map</span><span class="p">,</span> <span class="n">tried_pairs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tops</span> <span class="o">=</span> <span class="n">tops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span> <span class="o">=</span> <span class="n">sol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_atoms</span> <span class="o">=</span> <span class="n">available_atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flag_top_not_in_sol</span> <span class="o">=</span> <span class="n">flag_top_not_in_sol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol_atoms_map</span> <span class="o">=</span> <span class="n">sol_atoms_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span> <span class="o">=</span> <span class="n">tried_pairs</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1">#                                    updates and copying</span>
    <span class="c1">####################################################################################################################</span>
<div class="viewcode-block" id="AlchemicalSolution_base.copy"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy4update</span><span class="p">()</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_copy_sol_toptp</span><span class="p">(</span><span class="n">new_sol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_sol</span></div>

<div class="viewcode-block" id="AlchemicalSolution_base.copy_add_state"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.copy_add_state">[docs]</a>    <span class="k">def</span> <span class="nf">copy_add_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy4update</span><span class="p">()</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_copy_sol_toptp_add_state</span><span class="p">(</span><span class="n">new_sol</span><span class="p">)</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">_sol</span><span class="p">[</span><span class="n">new_sol</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">flag_top_not_in_sol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_sol</span></div>

<div class="viewcode-block" id="AlchemicalSolution_base.copy4update"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.copy4update">[docs]</a>    <span class="k">def</span> <span class="nf">copy4update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy4update_new_sol_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="AlchemicalSolution_base.copy4update_new_sol_df"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.copy4update_new_sol_df">[docs]</a>    <span class="k">def</span> <span class="nf">copy4update_new_sol_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sol_df</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AlchemicalSolution_base</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tops</span><span class="p">,</span> <span class="n">new_sol_df</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_atoms</span><span class="p">),</span>
                                          <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flag_top_not_in_sol</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="nb">list</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">__update_copy_sol_toptp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sol</span><span class="p">):</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">ptp_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">ptp_atom</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">at</span><span class="o">.</span><span class="n">ND_m_states</span><span class="p">:</span>
                <span class="n">at</span><span class="o">.</span><span class="n">ND_m_states</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">ND_m_states</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">at</span><span class="o">.</span><span class="n">ND_pch_states</span><span class="p">:</span>
                <span class="n">at</span><span class="o">.</span><span class="n">ND_pch_states</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">ND_pch_states</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">at</span><span class="o">.</span><span class="n">ND_a_type_states</span><span class="p">:</span>
                <span class="n">at</span><span class="o">.</span><span class="n">ND_a_type_states</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">ND_a_type_states</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">ptp_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">ptp_int</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">ptp_make_break_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">ptp_make_break_int</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">ptp_excl_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">ptp_excl_pair</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">excl_pair</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1">#print(len(self.toptp.excl_pair))</span>
        <span class="k">for</span> <span class="n">atom_pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">excl_pair</span><span class="p">:</span>
            <span class="n">new_atom_pair</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">at</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atom_pair</span><span class="p">)</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">excl_pair</span><span class="p">[</span><span class="n">new_atom_pair</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">excl_pair</span><span class="p">[</span><span class="n">atom_pair</span><span class="p">]</span>
            <span class="n">at1</span><span class="p">,</span> <span class="n">at2</span> <span class="o">=</span> <span class="n">new_atom_pair</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">add_atom_pair2EP_l</span><span class="p">(</span><span class="n">at1</span><span class="p">,</span> <span class="n">at2</span><span class="p">)</span>

<div class="viewcode-block" id="AlchemicalSolution_base.update_copy_sol_toptp"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.update_copy_sol_toptp">[docs]</a>    <span class="k">def</span> <span class="nf">update_copy_sol_toptp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sol</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;toptp&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update_copy_sol_toptp</span><span class="p">(</span><span class="n">new_sol</span><span class="p">)</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">interaction_states_map</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">int_st_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">int_st_map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">interaction_states_map</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlchemicalSolution_base.update_copy_sol_toptp_add_state"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.update_copy_sol_toptp_add_state">[docs]</a>    <span class="k">def</span> <span class="nf">update_copy_sol_toptp_add_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sol</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;toptp&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update_copy_sol_toptp</span><span class="p">(</span><span class="n">new_sol</span><span class="p">)</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">interaction_states_map</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">done_interactions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">int_st_map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">interaction_states_map</span><span class="p">:</span>
                <span class="n">temp_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">int_st_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">int_st_map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done_interactions</span><span class="p">:</span>
                        <span class="n">int_st_map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">int_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                        <span class="n">done_interactions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">int_st_map</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">temp_map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_st_map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">interaction_states_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_map</span><span class="p">)</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">interaction_states_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">())</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def __add_update_match2sol_atom_None_pair(self, matched_pair):</span>
<span class="sd">        new_row = pd.DataFrame([[None] * self._sol.shape[1]], dtype = object)</span>
<span class="sd">        if self._sol.shape[0]:</span>
<span class="sd">            new_row.index = [self._sol.index[-1] + 1]</span>
<span class="sd">        new_row[matched_pair[0][0]] = matched_pair[0][1]</span>
<span class="sd">        new_sol_df = self._sol.append(new_row)</span>
<span class="sd">        new_sol = AlchemicalSolution_base(self.tops, new_sol_df, list(self.available_atoms),</span>
<span class="sd">                                          list(self.flag_top_not_in_sol), self.sol_atoms_map.copy(), list())</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__add_update_match2sol_atom_atom_pair_with_Dummy_None</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matched_pair</span><span class="p">):</span>
        <span class="n">new_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">new_row</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_row</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_sol_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row</span><span class="p">)</span>
        <span class="n">new_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy4update_new_sol_df</span><span class="p">(</span><span class="n">new_sol_df</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Dummy</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">top_available_atoms</span> <span class="o">=</span> <span class="n">new_sol</span><span class="o">.</span><span class="n">available_atoms</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">top_available_atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">new_sol</span><span class="o">.</span><span class="n">available_atoms</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">top_available_atoms</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">top_available_atoms</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
                <span class="n">new_sol</span><span class="o">.</span><span class="n">flag_top_not_in_sol</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">new_sol</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_row</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_row_pair_identifier</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_row</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">temp_tried_pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">temp_tried_pair</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">matched_pair</span> <span class="ow">and</span> <span class="n">temp_tried_pair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="n">Dummy</span><span class="p">:</span>
                        <span class="n">updated_tried_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_row_pair_identifier</span><span class="p">,</span> <span class="n">temp_tried_pair</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">])</span> <span class="c1"># the other in pair</span>
                        <span class="k">if</span> <span class="n">updated_tried_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">updated_tried_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">updated_tried_pair</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">updated_tried_pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">:</span>
                            <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">updated_tried_pair</span><span class="p">)</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                    <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_tried_pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_sol</span>

    <span class="k">def</span> <span class="nf">__add_update_match2sol_row_atom_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matched_pair</span><span class="p">):</span>
        <span class="n">new_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy4update</span><span class="p">()</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">_sol</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="n">Dummy</span><span class="p">:</span>
            <span class="n">top_available_atoms</span> <span class="o">=</span> <span class="n">new_sol</span><span class="o">.</span><span class="n">available_atoms</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">top_available_atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">available_atoms</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">top_available_atoms</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">top_available_atoms</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">flag_top_not_in_sol</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Dummy</span><span class="p">:</span>
            <span class="n">row_identifier</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">temp_tried_pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">temp_tried_pair</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">updated_tried_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_identifier</span><span class="p">,</span> <span class="n">temp_tried_pair</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">])</span> <span class="c1"># the other in pair</span>
                        <span class="k">if</span> <span class="n">updated_tried_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">updated_tried_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">updated_tried_pair</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">updated_tried_pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">:</span>
                            <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">updated_tried_pair</span><span class="p">)</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">temp_tried_pair</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">temp_tried_pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">:</span>
                            <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_tried_pair</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_tried_pair</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_sol</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__update_row</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if row &lt; rows[1]:</span>
<span class="sd">            return row</span>
<span class="sd">        elif row == rows[1]:</span>
<span class="sd">            return rows[0]</span>
<span class="sd">        else:</span>
<span class="sd">            return row - 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">rows</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">row</span>

    <span class="k">def</span> <span class="nf">__updated_row_row_tried_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tried_pair</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tried_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tried_pair</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__update_row</span><span class="p">(</span><span class="n">tried_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">rows</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tried_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">row_0</span><span class="p">),</span> <span class="n">tried_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">row_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__update_row</span><span class="p">(</span><span class="n">tried_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">rows</span><span class="p">)</span>
                <span class="n">updated_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(((</span><span class="kc">None</span><span class="p">,</span> <span class="n">row_0</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">row_1</span><span class="p">))))</span>
                <span class="k">return</span> <span class="n">updated_pair</span>

    <span class="k">def</span> <span class="nf">__add_update_match2sol_row_row_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matched_pair</span><span class="p">):</span>
        <span class="n">new_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy4update</span><span class="p">()</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># has to be sorted!!!!!!!!!!!!</span>
        <span class="n">row4merging</span> <span class="o">=</span> <span class="n">new_sol</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rows</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">row4merging</span> <span class="o">=</span> <span class="n">row4merging</span><span class="p">[(</span><span class="n">row4merging</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row4merging</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">row4merging</span><span class="o">.</span><span class="n">values</span>
        <span class="n">new_sol</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">temp_top_i_atom</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">row4merging</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">row4merging</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">temp_top_i_atom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Dummy</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">new_sol</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="p">[</span><span class="n">temp_top_i_atom</span><span class="p">]</span> <span class="o">==</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># update the sol_atoms_map</span>
                <span class="n">new_sol</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="p">[</span><span class="n">temp_top_i_atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">temp_tried_pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">:</span>
            <span class="n">updated_tried_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__updated_row_row_tried_pair</span><span class="p">(</span><span class="n">temp_tried_pair</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">matched_pair</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">temp_tried_pair</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">updated_tried_pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">:</span>
                        <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">updated_tried_pair</span><span class="p">)</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                <span class="n">new_sol</span><span class="o">.</span><span class="n">tried_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">updated_tried_pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_sol</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def __add_update_match2sol_row_row_pair_with_reset(self, matched_pair):</span>
<span class="sd">        new_sol = AlchemicalSolution_base(self.tops, self._sol.copy(), list(self.available_atoms),</span>
<span class="sd">                                          list(self.flag_top_not_in_sol), self.sol_atoms_map.copy(), list())</span>
<span class="sd">        rows = matched_pair[0][1], matched_pair[1][1] # has to be sorted!!!!!!!!!!!!</span>
<span class="sd">        row4merging = new_sol._sol.iloc[rows[1]]</span>
<span class="sd">        row4merging = row4merging[(row4merging.values != None)]</span>
<span class="sd">        new_sol._sol.iloc[rows[0], row4merging.index] = row4merging.values</span>
<span class="sd">        new_sol._sol.drop(rows[1], inplace = True)</span>
<span class="sd">        for temp_top_i_atom in zip(row4merging.index, row4merging):</span>
<span class="sd">            if temp_top_i_atom[1] != Dummy:</span>
<span class="sd">                assert new_sol.sol_atoms_map[temp_top_i_atom] == matched_pair[1][1]</span>
<span class="sd">            #new_sol.sol_atoms_map[temp_top_i_atom] = matched_pair[0][1]</span>
<span class="sd">            # this is in principle the update if no reset is done...</span>
<span class="sd">        new_sol._sol.reset_index(drop = True, inplace = True)</span>
<span class="sd">        new_sol._get_sol_atoms_map()</span>
<span class="sd">        for temp_tried_pair in self.tried_pairs:</span>
<span class="sd">            updated_tried_pair = self.__updated_row_row_tried_pair(temp_tried_pair, rows)</span>
<span class="sd">            flag = True</span>
<span class="sd">            for i in range(2):</span>
<span class="sd">                if temp_tried_pair[i] == matched_pair[1]:</span>
<span class="sd">                    # if things get done without iloc and reseting the index, update has to be here...</span>
<span class="sd">                    if updated_tried_pair not in new_sol.tried_pairs:</span>
<span class="sd">                        new_sol.tried_pairs.append(updated_tried_pair)</span>
<span class="sd">                    flag = False</span>
<span class="sd">                    break</span>
<span class="sd">            if flag:</span>
<span class="sd">                new_sol.tried_pairs.append(updated_tried_pair)</span>
<span class="sd">        return new_sol</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AlchemicalSolution_base.add_match2sol"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.add_match2sol">[docs]</a>    <span class="k">def</span> <span class="nf">add_match2sol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matched_pair</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adds a matched pair (of atoms) to the current solution and creates a new one</span>
<span class="sd">        updates the other important variables (all from self.__init__ and tried_pairs)</span>
<span class="sd">        :param matched_pair:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># matched_pair is of this format (top_index, atom_key), (top_index, atom_key) -&gt; sorted by top_index</span>
        <span class="c1"># or (None, row_index), (top_index, atom_key) -&gt; always None, row_index first</span>
        <span class="c1"># or (None, row_index), (None, row_index) -&gt; row index not sorted</span>
        <span class="k">if</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_update_match2sol_atom_atom_pair_with_Dummy_None</span><span class="p">(</span><span class="n">matched_pair</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_update_match2sol_row_atom_pair</span><span class="p">(</span><span class="n">matched_pair</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_update_match2sol_row_row_pair</span><span class="p">(</span><span class="n">matched_pair</span><span class="p">)</span></div>
<span class="c1">#        return new_solution</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1">#                                           END</span>
    <span class="c1">#                                    updates and copying</span>
    <span class="c1">####################################################################################################################</span>

    <span class="k">def</span> <span class="nf">_get_sol_atoms_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol_atoms_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">row_i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">top_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">top_i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="p">[(</span><span class="n">top_i</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">top_i</span><span class="p">])]</span> <span class="o">=</span> <span class="n">row_i</span>

<div class="viewcode-block" id="AlchemicalSolution_base.transform_top_index_atom"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.transform_top_index_atom">[docs]</a>    <span class="k">def</span> <span class="nf">transform_top_index_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">top_index_atom</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">top_index_atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="p">[</span><span class="n">top_index_atom</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">top_index_atom</span></div>

<div class="viewcode-block" id="AlchemicalSolution_base.transform_top_index_atom_pair"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.transform_top_index_atom_pair">[docs]</a>    <span class="k">def</span> <span class="nf">transform_top_index_atom_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matched_pair</span><span class="p">):</span>
        <span class="n">transformed_matched_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_top_index_atom</span><span class="p">(</span><span class="n">temp_top_i_at</span><span class="p">)</span> <span class="k">for</span> <span class="n">temp_top_i_at</span> <span class="ow">in</span> <span class="n">matched_pair</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transformed_matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transformed_matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">transformed_matched_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">transformed_matched_pair</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transformed_matched_pair</span> <span class="o">=</span> <span class="n">transformed_matched_pair</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">transformed_matched_pair</span></div>

<div class="viewcode-block" id="AlchemicalSolution_base.update_tried_pairs"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.update_tried_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">update_tried_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">updated_tried_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">temp_tried_pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span><span class="p">:</span>
            <span class="n">updated_tried_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_top_index_atom_pair</span><span class="p">(</span><span class="n">temp_tried_pair</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">updated_tried_pairs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlchemicalSolution_base.states2df"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.states2df">[docs]</a>    <span class="k">def</span> <span class="nf">states2df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">temp_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">temp_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([[</span><span class="s1">&#39;top&#39;</span><span class="p">],</span> <span class="n">temp_df</span><span class="o">.</span><span class="n">columns</span><span class="p">])</span>
        <span class="n">temp_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([[</span><span class="s1">&#39;atom&#39;</span><span class="p">],</span> <span class="n">temp_df</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mask_dummies&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">temp_df</span> <span class="o">=</span> <span class="n">temp_df</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">temp_df</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">Dummy</span><span class="p">,</span> <span class="s1">&#39;DUM&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp_df</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states2df</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<div class="viewcode-block" id="AlchemicalSolution_base.find_common_atom_pair"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.find_common_atom_pair">[docs]</a>    <span class="k">def</span> <span class="nf">find_common_atom_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">top_atom0_index</span><span class="p">,</span> <span class="n">top1_index</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="p">[</span><span class="n">top_atom0_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">top1_index</span><span class="p">]</span></div>

<div class="viewcode-block" id="AlchemicalSolution_base.find_sol_atom"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution_base.find_sol_atom">[docs]</a>    <span class="k">def</span> <span class="nf">find_sol_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">top_atom0_index</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol_atoms_map</span><span class="p">[</span><span class="n">top_atom0_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptp</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">row</span><span class="p">]</span></div></div>

<div class="viewcode-block" id="AlchemicalSolution"><a class="viewcode-back" href="../../../SMArt.alchemy.html#SMArt.alchemy.incl.AlchemicalSolution">[docs]</a><span class="k">class</span> <span class="nc">AlchemicalSolution</span><span class="p">(</span><span class="n">AlchemicalSolution_base</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param tops:</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            available_atoms</span>
<span class="sd">                ((n-atoms of 1st top), (m-atoms of 2nd top), (l-atoms of 3rd top), ...)</span>
<span class="sd">                e.g. (None, (1,2,3,4,6,8), (), None)</span>
<span class="sd">                    None - all atoms</span>
<span class="sd">                    4 topologies, all atoms from the 1st and 4th topology, (1,2,3,4,6,8) from 2nd, none from 3rd</span>
<span class="sd">                    () - no atoms (needed for divide-and-conquer implementation</span>
<span class="sd">            common_atoms</span>
<span class="sd">                ((n-atoms of 1st top), (n-atoms of 2nd top), (n-atoms of 3rd top), ...)</span>
<span class="sd">                e.g. [[1,3,8], [1,4,8], [1, Dummy, 7], [2, 4, None]]</span>
<span class="sd">                    4 topologies, atoms (1, 1, 1, 2); (3, 4, dummy, 4) and (8, 8, 7, ?) are common</span>
<span class="sd">                    Dummy means dummy, None means not decided yet</span>
<span class="sd">            tried_pairs</span>
<span class="sd">                [((top_index, atom), (top_index, atom)), ((top_index, atom), (top_index, atom)), ...]</span>
<span class="sd">                e.g. [((0,1), (1,1)), ((0,1), (2,2)), ((1,2), (2,3))]</span>
<span class="sd">                three pairs - tops[0].atoms[1] and tops[1].atoms[1]; tops[0].atoms[1] and tops[2].atoms[2], ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tops</span> <span class="o">=</span> <span class="n">tops</span>
        <span class="n">common_atoms</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;common_atoms&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">common_atoms</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_atoms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">common_atoms</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_sol_atoms_map</span><span class="p">()</span>
        <span class="n">available_atoms</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;available_atoms&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">available_atoms</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">available_atoms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">available_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">top_i</span><span class="p">,</span> <span class="n">top_av_atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">available_atoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">available_atoms</span><span class="p">[</span><span class="n">top_i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">temp_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tops</span><span class="p">[</span><span class="n">top_i</span><span class="p">]</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">temp_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">available_atoms</span><span class="p">[</span><span class="n">top_i</span><span class="p">])</span>
            <span class="n">temp_atoms_in_solution</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="p">[</span><span class="n">top_i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">available_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">temp_set</span> <span class="o">-</span> <span class="n">temp_atoms_in_solution</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__get_flag_top_not_in_sol</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tried_pairs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tried_pairs&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_tried_pairs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matches_layers</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;N_layers&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">__get_flag_top_not_in_sol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># shape = len(tops); True if not a single atom in solution yet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flag_top_not_in_sol</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="p">[</span><span class="n">top_i</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="k">for</span> <span class="n">top_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flag_top_not_in_sol</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Drazen Petrov.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>